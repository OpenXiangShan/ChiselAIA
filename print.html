<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ChiselAIA</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">ChiselAIA</li><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> üò∫AIA</a></li><li class="chapter-item expanded "><a href="imsic.html"><strong aria-hidden="true">2.</strong> üì©IMSIC</a></li><li class="chapter-item expanded "><a href="aplic.html"><strong aria-hidden="true">3.</strong> üß∂APLIC</a></li><li class="chapter-item expanded "><a href="integration.html"><strong aria-hidden="true">4.</strong> üß≠ÈõÜÊàêÊåáÂçóÔºàIntegration GuideÔºâ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ChiselAIA</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://openxiangshan.github.io/ChiselAIA/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chiselaia"><a class="header" href="#chiselaia">üò∫ChiselAIA</a></h1>
<!-- vim-markdown-toc GFM -->
<ul>
<li><a href="index.html#%E7%AE%80%E4%BB%8Bintroduction">ÁÆÄ‰ªãÔºàIntroductionÔºâ</a></li>
<li><a href="index.html#%E4%B8%AD%E6%96%AD%E9%80%9A%E8%B7%AFinterrupt-paths">‰∏≠Êñ≠ÈÄöË∑ØÔºàInterrupt PathsÔºâ</a></li>
<li><a href="index.html#%E9%85%8D%E7%BD%AE%E9%80%9A%E8%B7%AFconfiguration-paths">ÈÖçÁΩÆÈÄöË∑ØÔºàConfiguration PathsÔºâ</a></li>
<li><a href="index.html#%E5%BC%95%E7%94%A8references">ÂºïÁî®ÔºàReferencesÔºâ</a></li>
</ul>
<!-- vim-markdown-toc -->
<p>ChiselAIAÁöÑÂÆûÁé∞ÈÅµÂæ™<a href="https://github.com/riscv/riscv-aia">RISC-VÈ´òÁ∫ß‰∏≠Êñ≠Êû∂ÊûÑÔºàAdvanced Interrupt Architecture, AIAÔºâËßÑËåÉ</a>„ÄÇ
ÂÆûÁé∞‰∏éËßÑËåÉ‰πãÈó¥ÁöÑ‰ªª‰ΩïÂ∑ÆÂºÇÈÉΩÂ∫îËßÜ‰∏∫ÂÆûÁé∞bug„ÄÇ</p>
<p>The implementation of ChiselAIA adheres to the <a href="https://github.com/riscv/riscv-aia">RISC-V Advanced Interrupt Architecture (AIA) Specification</a>.
Any discrepancies between the implementation and specification should be treated as implementation bugs.</p>
<h2 id="ÁÆÄ‰ªãintroduction"><a class="header" href="#ÁÆÄ‰ªãintroduction">ÁÆÄ‰ªãÔºàIntroductionÔºâ</a></h2>
<p>AIAÊó®Âú®È´òÊïàÂú∞Â∞ÜÂ§ñÈÉ®‰∏≠Êñ≠Ë∑ØÁî±Âà∞ÂØπÂ∫îÁöÑÂ§ÑÁêÜÂô®Ê†∏ÂøÉÔºàhartÔºâÂíåÁâπÊùÉÊÄÅ„ÄÇ
ËøôÁßçË∑ØÁî±ÈÄöËøá‰∏§‰∏™‰∏≠Êñ≠ÊéßÂà∂Âô®Êù•ÂÆåÊàêÔºö</p>
<p>AIA is designed to efficiently route external interrupts to the appropriate harts and privilege levels.
This routing is accomplished by two interrupt controllers:</p>
<ul>
<li>Incoming Message-Signaled Interrupt Controller (<strong>IMSIC</strong>)</li>
<li>Advanced Platform-Level Interrupt Controller (<strong>APLIC</strong>)</li>
</ul>
<p>‰∏∫‰ªÄ‰πàÈúÄË¶Å‰∏§ÁßçÊéßÂà∂Âô®Ôºü
Âõ†‰∏∫Â≠òÂú®‰∏§Á±ªÂ§ñÈÉ®ËÆæÂ§áÔºö</p>
<ol>
<li><strong>Á∫øËÆæÂ§á</strong>Ôºö
ÈÄöËøá‰∏ìÁî®ÁöÑÁîµ‰ø°Âè∑ÔºàËæπÊ≤øÊàñÁîµÂπ≥Ôºâ‰º†Ëæì‰∏≠Êñ≠„ÄÇ
ÂÆÉÁöÑÁâπÁÇπÊòØÂÆûÁé∞ÁÆÄÂçïÔºåÂèØÊâ©Â±ïÊÄßÂ∑Æ„ÄÇ
Âõ†‰∏∫ÊØè‰∏™‰∏≠Êñ≠ÈÉΩÊÑèÂë≥ÁùÄ‰∏ÄÊ†πËøûÊé•Âà∞Â§ÑÁêÜÂô®Ê†∏ÂøÉÁöÑÁâ©ÁêÜÁ∫ø„ÄÇ</li>
<li><strong>Ê∂àÊÅØ‰ø°Âè∑‰∏≠Êñ≠(Message-signaled-interrupt, MSI)ËÆæÂ§á</strong>Ôºö
‰∏≠Êñ≠Ë¢´ÁºñÁ†Å‰∏∫Ê∂àÊÅØÔºåÂπ∂ÈÄöËøáÊÄªÁ∫ø/ÁΩëÁªú‰º†Ëæì„ÄÇ
Âõ†‰∏∫ÊØè‰∏™‰∏≠Êñ≠‰∏çÈúÄË¶Å‰∏ìÁî®ÁöÑÁâ©ÁêÜËøûÁ∫øÔºåÂõ†Ê≠§MSI‰∏éÁ∫ø‰∏≠Êñ≠Áõ∏ÊØîÔºåÊúâÊõ¥Â•ΩÁöÑÂèØÊâ©Â±ïÊÄß„ÄÇ</li>
</ol>
<p>Why two types of controllers?
There are two types of external devices:</p>
<ol>
<li><strong>Wired devices</strong>:
Interrupts are transmitted via dedicated electronic signals (edge or level),
which is simple to implement but faces scalability challenges,
as each interrupt requires an physical wire connected to the hart.</li>
<li><strong>Message-signaled-interrupt (MSI) devices</strong>:
Interrupts are encoded as messages and transmitted over bus/network,
which offers better scalability compared to wired interrupts,
as no dedicated physical wires needed for each interrupt.</li>
</ol>
<p>Âú® RISC-V AIA ‰∏≠Ôºö</p>
<ul>
<li><strong>APLIC</strong>Ë¥üË¥£Â§ÑÁêÜÁ∫øÂ§ñÈÉ®‰∏≠Êñ≠„ÄÇ
<strong>Ê≥®ÊÑè</strong>ÔºöAPLICÂèØ‰ª•Âú®‰∏§ÁßçÊ®°Âºè‰∏ãËøêË°å(domaincfg.DM)Ôºö
<ul>
<li><strong>Áõ¥Êé•ÈÄíÈÄÅÊ®°Âºè</strong>ÔºöAPLICÁõ¥Êé•Â∞ÜÁ∫ø‰∏≠Êñ≠Ë∑ØÁî±Âà∞Â§ÑÁêÜÂô®Ê†∏ÂøÉÔºåÊó†ÈúÄIMSICÂèÇ‰∏é„ÄÇ</li>
<li>MSIÈÄíÈÄÅÊ®°ÂºèÔºöAPLICÂ∞ÜÁ∫ø‰∏≠Êñ≠ËΩ¨Êç¢‰∏∫MSIÂπ∂ËΩ¨ÂèëÁªôIMSIC„ÄÇ</li>
<li>Áî±‰∫éMSIÊõ¥ÂÖ∑Êâ©Â±ïÊÄßÔºåÂêéÁª≠ËÆ®ËÆ∫ÈªòËÆ§APLICÈááÁî®MSIÈÄíÈÄÅÊ®°Âºè„ÄÇ</li>
</ul>
</li>
<li><strong>IMSIC</strong>Ë¥üË¥£Â§ÑÁêÜMSI„ÄÇ</li>
</ul>
<p>In RISC-V AIA:</p>
<ul>
<li><strong>APLIC</strong> handles wired external interrupts.
<strong>Note</strong>: APLIC can operate in two modes (<code>domaincfg.DM</code>):
<ul>
<li><strong>Direct delivery mode</strong>: APLIC directly routes wired interrupts to harts without IMSIC involvement.</li>
<li><strong>MSI delivery mode</strong>: APLIC converts wired interrupts into MSIs and forwards them to IMSIC.</li>
<li>Since MSIs represent the more scalable approach, our subsequent discussion assumes the APLIC working in MSI delivery mode.</li>
</ul>
</li>
<li><strong>IMSIC</strong> handles MSIs.</li>
</ul>
<p>ËÆæÂ§á„ÄÅ‰∏≠Êñ≠ÊéßÂà∂Âô®ÂíåÂ§ÑÁêÜÂô®Ê†∏ÂøÉ‰πãÈó¥ÁöÑ‰∫§‰∫í‰∏ªË¶ÅÊ∂âÂèä‰∏§ÁßçÊï∞ÊçÆÈÄöË∑ØÔºö
<strong>‰∏≠Êñ≠ÈÄöË∑Ø</strong>Âíå<strong>ÈÖçÁΩÆÈÄöË∑Ø</strong>ÔºåÂ¶Ç‰∏ãÈù¢‰∏§Âº†ÂõæÊâÄÁ§∫„ÄÇ</p>
<p>The interaction between devices, interrupt controllers, and harts involves two main types of data paths:
<strong>interrupt paths</strong> and <strong>configuration paths</strong>, shown as the following two figures.</p>
<h2 id="‰∏≠Êñ≠ÈÄöË∑Øinterrupt-paths"><a class="header" href="#‰∏≠Êñ≠ÈÄöË∑Øinterrupt-paths">‰∏≠Êñ≠ÈÄöË∑ØÔºàInterrupt PathsÔºâ</a></h2>
<p>Â§ñÈÉ®‰∏≠Êñ≠‰∏ªË¶ÅÊ∫êËá™Â§ñÈÉ®ËÆæÂ§áÔºå
Â∞ΩÁÆ°Âú®È´òÁ∫ß‰ΩøÁî®Âú∫ÊôØ‰∏≠ÔºåÂÜÖÈÉ®ËÆæÂ§áÂíåÂ§ÑÁêÜÂô®Ê†∏ÂøÉ‰πüÂèØ‰ª•ÁîüÊàê‚ÄúÂ§ñÈÉ®‚Äù‰∏≠Êñ≠
Ôºà‰æãÂ¶ÇÂΩìÁõëÁÆ°ÊÄÅÂêëËôöÊãüÂåñÁõëÁÆ°ÊÄÅÊ≥®ÂÖ•Â§ñÈÉ®‰∏≠Êñ≠Êó∂Ôºâ„ÄÇ
Êé•‰∏ãÊù•ÁöÑËÆ®ËÆ∫ÈáçÁÇπÂÖ≥Ê≥®Â§ñÈÉ®ËÆæÂ§áÁîüÊàê‰∏≠Êñ≠Âπ∂ÈÄöËøáÊéßÂà∂Âô®Ë∑ØÁî±Âà∞Â§ÑÁêÜÂô®Ê†∏ÂøÉÁöÑÂÖ∏ÂûãÊÉÖÂÜµ„ÄÇ</p>
<p>External interrupts primarily originate from external devices,
though in advanced scenarios, internal devices and harts can also generate "external" interrupts
(e.g. when supervisor level injects external interrupts into virtualized supervisor level).
The following discussion focuses on the typical case where external devices generate interrupts that are routed through controllers to harts.</p>
<p><img src="./images/arch_interrupt_py.svg" alt="" /></p>
<p>ËØ¶ÁªÜÁöÑ‰∏≠Êñ≠ÈÄöË∑ØÂ¶Ç‰∏ãÔºàÊ≥®ÔºöÂú®ËØ≠Ë®ÄÊ∏ÖÊô∞ÂâçÊèê‰∏ãÔºåÊàë‰ª¨Â∞ÜÁúÅÁï•‚ÄúÂ§ñÈÉ®‚ÄùÔºâÔºö</p>
<ul>
<li>‰∏≠Êñ≠Êù•Ê∫ê‰∫éÁ∫øËÆæÂ§áÊàñMSIËÆæÂ§áÔºö
<ul>
<li>Á∫øËÆæÂ§áÈÄöË∑ØÔºö
<ul>
<li>‰∏≠Êñ≠Ë¢´ËΩ¨ÂèëÂà∞APLICÁöÑ<strong>‰∏≠Êñ≠Âüü</strong>„ÄÇ</li>
<li>ÊØè‰∏™ÂüüË¥üË¥£ÁÆ°ÁêÜÊüê‰∏ÄÁâπÊùÉÊÄÅÁöÑ‰∏ÄÁªÑÂ§ÑÁêÜÂô®Ê†∏ÂøÉÁöÑ‰∏≠Êñ≠„ÄÇ</li>
<li>ÂØπ‰∫éÂ§ßÂûãÂØπÁß∞Â§öÂ§ÑÁêÜÁ≥ªÁªüÔºåÈÄöÂ∏∏‰∏§‰∏™ÂüüÂ∞±Ë∂≥Â§ü‰∫Ü<sup class="footnote-reference"><a href="#two_interrupt_domains">1</a></sup>Ôºö
<ul>
<li>‰∏Ä‰∏™<strong>Êú∫Âô®ÊÄÅÂüü</strong>Ôºå</li>
<li>‰∏Ä‰∏™<strong>ÁõëÁÆ°ÊÄÅÂüü</strong>„ÄÇ</li>
</ul>
</li>
<li>ÂüüÈÅµÂæ™Â±ÇÁ∫ßÁªìÊûÑÔºö
<ul>
<li>ÊâÄÁ∫ø‰∏≠Êñ≠È¶ñÂÖàÂà∞ËææÊú∫Âô®ÊÄÅÂüü„ÄÇ</li>
<li>Ê†πÊçÆAPLICÁöÑÈÖçÁΩÆÔºåÊØè‰∏™‰∏≠Êñ≠ÂèØ‰ª•Ôºö
<ul>
<li>ËΩ¨Êç¢‰∏∫MSIÂπ∂ÈÄöËøáÊÄªÁ∫ø/ÁΩëÁªúËΩ¨ÂèëÁªôIMSICÔºå</li>
<li>ÂßîÊâòÁªôÂ≠êÂüüÔºåÁÑ∂ÂêéÈÅµÂæ™Á±ª‰ººÁöÑÂ§ÑÁêÜÊµÅÁ®ã„ÄÇ</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>MSIËÆæÂ§áÈÄöË∑ØÔºö
<ul>
<li>MSIÈÄöËøáÊÄªÁ∫ø/ÁΩëÁªúÁõ¥Êé•Ë∑ØÁî±Âà∞IMSIC„ÄÇ</li>
</ul>
</li>
</ul>
</li>
<li>IMSICÂ§ÑÁêÜÊµÅÁ®ãÔºö
<ul>
<li>ÊØè‰∏™Â§ÑÁêÜÂô®Ê†∏ÂøÉÈÄöÂ∏∏ÊúâÂÖ∂‰∏ìÁî®ÁöÑIMSIC„ÄÇ</li>
<li>ÊØè‰∏™IMSICÂåÖÂê´Â§ö‰∏™‰∏≠Êñ≠Êñá‰ª∂ÔºåÊØè‰∏™ÁâπÊùÉÊÄÅÂØπÂ∫î‰∏Ä‰∏™<strong>‰∏≠Êñ≠Êñá‰ª∂</strong><sup class="footnote-reference"><a href="#one_imsic_per_hart">2</a></sup>Ôºö
<ul>
<li>‰∏Ä‰∏™<strong>Êú∫Âô®ÊÄÅ</strong>Ôºå</li>
<li>‰∏Ä‰∏™<strong>ÁõëÁÆ°ÊÄÅ</strong>Ôºå</li>
<li>Â§ö‰∏™<strong>ËôöÊãüÂåñÁõëÁÆ°ÊÄÅ</strong>„ÄÇ</li>
</ul>
</li>
<li>ÊØè‰∏™‰∏≠Êñ≠Êñá‰ª∂Ôºö
<ul>
<li>Áª¥Êä§‰∏≠Êñ≠Áä∂ÊÄÅ(ÂæÖÂ§ÑÁêÜ„ÄÅ‰ΩøËÉΩÁ≠â)Ôºå</li>
<li>Ê†πÊçÆÈÖçÁΩÆÈÄöËøáÁ∫øË∑ØÂêëÂ§ÑÁêÜÂô®Ê†∏ÂøÉÂèëÂá∫‰∏≠Êñ≠‰ø°Âè∑„ÄÇ</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Here are the detailed interrupts paths (note: "external" is omitted where context is clear):</p>
<ul>
<li>Interrupts originate from either wired devices or MSI devices:
<ul>
<li>Wired device paths:
<ul>
<li>Interrupts are directed to APLIC's <strong>interrupt domains</strong>.</li>
<li>Each domain manages interrupts for a specific set of harts at a given privilege level.</li>
<li>For large symmetric multiprocessing systems, typically two domains suffice<sup class="footnote-reference"><a href="#two_interrupt_domains">1</a></sup>:
<ul>
<li>One <strong>machine-level domain</strong>,</li>
<li>One <strong>supervisor-level domain</strong>.</li>
</ul>
</li>
<li>Domains follow a hierarchical structure:
<ul>
<li>All wired interrupts fist arrive at the machine-level domain.</li>
<li>Based on APLIC configuration, each interrup is either:
<ul>
<li>Converted to MSI and forwarded to IMSIC via bus/network,</li>
<li>Delegated to child domains, which then follow similar processing.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>MSI device paths:
<ul>
<li>MSIs route directly to IMSIC via bus/network.</li>
</ul>
</li>
</ul>
</li>
<li>IMSIC processing:
<ul>
<li>Each hart typically has its dedicated IMSIC.</li>
<li>Each IMSIC contains multiple <strong>interrupt files</strong>, one per privilege level<sup class="footnote-reference"><a href="#one_imsic_per_hart">2</a></sup>:
<ul>
<li>One <strong>machine level</strong>,</li>
<li>One <strong>supervisor level</strong>,</li>
<li>Multiple <strong>virtualized supervisor levels</strong>.</li>
</ul>
</li>
<li>Each interrupt file:
<ul>
<li>Maintains interrup status (pending, enabled, ...),</li>
<li>Signals hart based on configuration via wire connection.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ÈÖçÁΩÆÈÄöË∑Øconfiguration-paths"><a class="header" href="#ÈÖçÁΩÆÈÄöË∑Øconfiguration-paths">ÈÖçÁΩÆÈÄöË∑ØÔºàConfiguration PathsÔºâ</a></h2>
<p>ÈÖçÁΩÆÊµÅÁ®ãÈÅµÂæ™‰∏§‰∏™‰∏çÂêåÁöÑÈÄöË∑ØÔºö</p>
<ul>
<li>IMSICÈÖçÁΩÆÔºö
<ul>
<li>ÊØè‰∏™Â§ÑÁêÜÂô®Ê†∏ÂøÉÂè™ÈÖçÁΩÆÂÖ∂‰∏ìÁî®ÁöÑIMSICÔºå</li>
<li>ÈÖçÁΩÆÈÄöËøáÁ∫øË∑ØËøûÊé•ËøõË°å„ÄÇ</li>
</ul>
</li>
<li>APLICÈÖçÁΩÆÔºö
<ul>
<li>ÊâÄÊúâÂ§ÑÁêÜÂô®Ê†∏ÂøÉÈÉΩÂèØ‰ª•ÈÖçÁΩÆAPLICÔºå</li>
<li>ÈÖçÁΩÆ‰ª•Ê∂àÊÅØÂΩ¢ÂºèÈÄöËøáÊÄªÁ∫ø‰º†Ëæì„ÄÇ</li>
</ul>
</li>
</ul>
<p>Configuration flow follows two distinct paths:</p>
<ul>
<li>IMSIC configuration:
<ul>
<li>Each hart configures only its dedicated IMSIC,</li>
<li>Configuration occurs through direct wire connection.</li>
</ul>
</li>
<li>APLIC Configuration:
<ul>
<li>All harts can configure APLIC,</li>
<li>Configuration transmitted via bus as messages.</li>
</ul>
</li>
</ul>
<p><img src="./images/arch_configure_py.svg" alt="" /></p>
<h2 id="ÂºïÁî®references"><a class="header" href="#ÂºïÁî®references">ÂºïÁî®ÔºàReferencesÔºâ</a></h2>
<ul>
<li>
<div class="footnote-definition" id="two_interrupt_domains"><sup class="footnote-definition-label">1</sup>
<p><em>The RISC-V Advanced Interrupt Architecture</em>: 4.2 Interrupt domains: Figure 4.</p>
</div>
</li>
<li>
<div class="footnote-definition" id="one_imsic_per_hart"><sup class="footnote-definition-label">2</sup>
<p><em>The RISC-V Advanced Interrupt Architecture</em>: 1.3.2. External interrupts with IMSICs.</p>
</div>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imsic"><a class="header" href="#imsic">üì©IMSIC</a></h1>
<!-- vim-markdown-toc GFM -->
<ul>
<li><a href="imsic.html#%E5%8D%95%E4%B8%AAimsic%E7%9A%84%E5%8A%9F%E8%83%BDindividual-imsic-functionality">Âçï‰∏™IMSICÁöÑÂäüËÉΩÔºàIndividual IMSIC FunctionalityÔºâ</a>
<ul>
<li><a href="imsic.html#imsic%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BAimsic-io">IMSICÁöÑËæìÂÖ•‰∏éËæìÂá∫ÔºàIMSIC IOÔºâ</a></li>
<li><a href="imsic.html#%E4%B8%AD%E6%96%AD%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BAinterrupt-file-io">‰∏≠Êñ≠Êñá‰ª∂ÁöÑËæìÂÖ•‰∏éËæìÂá∫ÔºàInterrupt File IOÔºâ</a></li>
<li><a href="imsic.html#%E4%B8%AD%E6%96%AD%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%AF%84%E5%AD%98%E5%99%A8interrupt-file-memory-mapped-registers">‰∏≠Êñ≠Êñá‰ª∂ÁöÑÂÜÖÂ≠òÊò†Â∞ÑÂØÑÂ≠òÂô®ÔºàInterrupt File Memory-mapped RegistersÔºâ</a></li>
<li><a href="imsic.html#%E4%B8%AD%E6%96%AD%E6%96%87%E4%BB%B6%E5%86%85%E9%83%A8%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8interrupt-file-internal-registers">‰∏≠Êñ≠Êñá‰ª∂ÂÜÖÈÉ®ÁöÑÂØÑÂ≠òÂô®ÔºàInterrupt File Internal RegistersÔºâ</a></li>
</ul>
</li>
<li><a href="imsic.html#%E5%A4%9A%E4%B8%AAimsic%E7%9A%84%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8Fmultiple-imsics-arrangement">Â§ö‰∏™IMSICÁöÑÁªÑÁªáÂΩ¢ÂºèÔºàMultiple IMSICs ArrangementÔºâ</a>
<ul>
<li><a href="imsic.html#imsic%E5%9C%B0%E5%9D%80%E5%AD%97%E6%AE%B5imsic-address-fields">IMSICÂú∞ÂùÄÂ≠óÊÆµÔºàIMSIC Address FieldsÔºâ</a></li>
<li><a href="imsic.html#imsic%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9Fimsic-memory-regions">IMSICÂÜÖÂ≠òÂå∫ÂüüÔºàIMSIC Memory RegionsÔºâ</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<p>Âú®ÂÖ∏ÂûãÁöÑRISC-VÁ≥ªÁªü‰∏≠ÔºåÊØè‰∏™Â§ÑÁêÜÂô®Ê†∏ÂøÉÈÉΩÈÖçÊúâ‰∏ìÁî®ÁöÑIMSIC„ÄÇ
IMSICÊâßË°å‰∏â‰∏™‰∏ªË¶ÅÂäüËÉΩ:</p>
<ul>
<li>ÈÄöËøáÂÜÖÂ≠òÊò†Â∞ÑÂØÑÂ≠òÂô®Êé•Êî∂MSIÔºå</li>
<li>‰∏∫ÂÖ∂ÂÖ≥ËÅîÁöÑÂ§ÑÁêÜÂô®Ê†∏ÂøÉÁîüÊàê‰∏≠Êñ≠Ôºå</li>
<li>ÁÆ°ÁêÜÂ§ÑÁêÜÂô®Ê†∏ÂøÉÊâÄÈúÄÁöÑAIAÊéßÂà∂ÂØÑÂ≠òÂô®„ÄÇ</li>
</ul>
<p>In a typical RISC-V system, each hart is paired with its dedicated IMSIC.
The IMSIC performs three main functions:</p>
<ul>
<li>Receives MSIs through memory-mapped registers,</li>
<li>Generates interrupts for its associated hart,</li>
<li>Manages AIA CSRs under hart control.</li>
</ul>
<p>Âú®ÂØπÁß∞Â§öÂ§ÑÁêÜÁ≥ªÁªü‰∏≠ÔºåÂ§ö‰∏™‚ÄúÊ†∏-IMSIC‚ÄùÂØπÂèØ‰ª•ÂàíÂàÜÊàêÁªÑÔºå
ÊØèÁªÑÂåÖÂê´Áõ∏ÂêåÊï∞ÈáèÁöÑÊ†∏-IMSICÂØπ„ÄÇ</p>
<p>In symmetric multiprocessing systems, multiple harts-IMSIC pairs can be organized into groups,
with each group containing an equal number of pairs.</p>
<h2 id="Âçï‰∏™imsicÁöÑÂäüËÉΩindividual-imsic-functionality"><a class="header" href="#Âçï‰∏™imsicÁöÑÂäüËÉΩindividual-imsic-functionality">Âçï‰∏™IMSICÁöÑÂäüËÉΩÔºàIndividual IMSIC FunctionalityÔºâ</a></h2>
<h3 id="imsicÁöÑËæìÂÖ•‰∏éËæìÂá∫imsic-io"><a class="header" href="#imsicÁöÑËæìÂÖ•‰∏éËæìÂá∫imsic-io">IMSICÁöÑËæìÂÖ•‰∏éËæìÂá∫ÔºàIMSIC IOÔºâ</a></h3>
<p>IMSIC‰∏éÂÖ∂Â§ÑÁêÜÂô®Ê†∏ÂøÉÁ¥ßÂØÜËÄ¶ÂêàÔºå
Áõ¥Êé•‰ΩøÁî®Á∫øË∑ØËøûÊé•ËÄå‰∏çÊòØÊÄªÁ∫ø/ÁΩëÁªúËøõË°å‰ø°ÊÅØ‰º†Ëæì„ÄÇ
ÂÖ∂ÂÖ≥ÈîÆ‰ø°Âè∑ÂåÖÊã¨:</p>
<ul>
<li><code>pendings</code>: ÊØè‰∏™‰∏≠Êñ≠Êñá‰ª∂ÁöÑÂæÖÂ§ÑÁêÜ‰∏≠Êñ≠Áä∂ÊÄÅ„ÄÇ</li>
<li><code>{m,s,vs}topei</code>: ÊØè‰∏™ÁâπÊùÉÊÄÅ‰∏≠Ôºå‰ºòÂÖàÁ∫ßÊúÄÈ´òÁöÑÂ§ñÈÉ®‰∏≠Êñ≠Âè∑„ÄÇ</li>
<li><code>{m.s,vs}iselect</code>: ÊØè‰∏™ÁâπÊùÉÊÄÅ‰∏≠ÔºåÈó¥Êé•ËÆøÈóÆÊéßÂà∂ÂØÑÂ≠òÂô®ÁöÑÂú∞ÂùÄ„ÄÇ</li>
<li><code>{m,s,vs}ireg</code>: ÊØè‰∏™ÁâπÊùÉÊÄÅ‰∏≠ÔºåÈó¥Êé•ËÆøÈóÆÊéßÂà∂ÂØÑÂ≠òÂô®ÊâÄËØªÂÜôÁöÑÊï∞ÊçÆ„ÄÇ</li>
<li><code>vgein</code>: ËôöÊãüÂåñÁõëÁÆ°ÊÄÅÁöÑÈÄâÊã©‰ø°Âè∑„ÄÇ</li>
</ul>
<p>The IMSIC is tightly coupled with its hart,
directly using wire connection rather than bus/network for information transfer.
Key signals include:</p>
<ul>
<li><code>pendings</code>: Pending interrupt status for each interrupt file.</li>
<li><code>{m,s,vs}topei</code>: Top external interrupt ID for each privilege level.</li>
<li><code>{m.s,vs}iselect</code>: CSR indirect access address for each privilege level.</li>
<li><code>{m,s,vs}ireg</code>: Read and write data for indirect CSR access for each privilege level.</li>
<li><code>vgein</code>: Virtualized supervisor level selector.</li>
</ul>
<p><img src="./images/imsic_py.svg" alt="" /></p>
<h3 id="‰∏≠Êñ≠Êñá‰ª∂ÁöÑËæìÂÖ•‰∏éËæìÂá∫interrupt-file-io"><a class="header" href="#‰∏≠Êñ≠Êñá‰ª∂ÁöÑËæìÂÖ•‰∏éËæìÂá∫interrupt-file-io">‰∏≠Êñ≠Êñá‰ª∂ÁöÑËæìÂÖ•‰∏éËæìÂá∫ÔºàInterrupt File IOÔºâ</a></h3>
<p>‰∏Ä‰∏™IMSICË¥üË¥£ÁÆ°ÁêÜÂÖ∂Â§ÑÁêÜÂô®Ê†∏ÂøÉ‰∏≠ÁöÑÊâÄÊúâÁâπÊùÉÊÄÅÔºå
ÂåÖÊã¨Ôºö‰∏Ä‰∏™Êú∫Âô®ÊÄÅ„ÄÅ‰∏Ä‰∏™ÁõëÁÆ°ÊÄÅÂíåÂ§ö‰∏™ËôöÊãüÂåñÁõëÁÆ°ÊÄÅ„ÄÇ
Áî±‰∫éÊØè‰∏™ÊÄÅÁöÑË°å‰∏∫Âú®‰∏ÄËà¨ÊÉÖÂÜµ‰∏ãÊòØÁõ∏ÂêåÁöÑÔºåAIAËßÑËåÉÂ∞ÜËøô‰∫õÂäüËÉΩÊ®°ÂùóÂåñÊàêÁã¨Á´ã‰∏îÂèØÈáçÁî®ÁöÑÁªÑ‰ª∂ÔºåÁß∞‰∏∫‰∏≠Êñ≠Êñá‰ª∂„ÄÇ
ÊØè‰∏™‰∏≠Êñ≠Êñá‰ª∂‰∏éIMSIC‰∫§Êç¢‰∏éÁâπÊùÉÊÄÅÊó†ÂÖ≥ÁöÑ‰ø°ÊÅØ:</p>
<ul>
<li><code>pending</code>: ËØ•‰∏≠Êñ≠Êñá‰ª∂ÁöÑ‰∏≠Êñ≠Áä∂ÊÄÅ„ÄÇ</li>
<li><code>topei</code>: ËØ•‰∏≠Êñ≠Êñá‰ª∂‰∏≠Ôºå‰ºòÂÖàÁ∫ßÊúÄÈ´òÁöÑÂ§ñÈÉ®‰∏≠Êñ≠Âè∑„ÄÇ</li>
<li><code>iselect</code>: ËØ•‰∏≠Êñ≠Êñá‰ª∂‰∏≠ÔºåÈó¥Êé•ËÆøÈóÆÊéßÂà∂ÂØÑÂ≠òÂô®ÁöÑÂú∞ÂùÄ„ÄÇ</li>
<li><code>ireg</code>: ËØ•‰∏≠Êñ≠Êñá‰ª∂‰∏≠ÔºåÈó¥Êé•ËÆøÈóÆÊéßÂà∂ÂØÑÂ≠òÂô®ÊâÄËØªÂÜôÁöÑÊï∞ÊçÆ„ÄÇ</li>
</ul>
<p>One IMSIC manages all privilege levels in its hart,
including: one machine level, one supervisor level, and multiple virtualized supervisor levels.
As the behaviors of each level are identical in general, the AIA specification modularizes these functionalities of each level into independent and reusable components, called interrupt files.
Each interrupt file exchanges privilege-agnostic information with IMSIC:</p>
<ul>
<li><code>pending</code>: Interrupt pending status for this interrupt file.</li>
<li><code>topei</code>: Top external interrupt ID for this interrupt file.</li>
<li><code>iselect</code>: CSR indirect access address for this interrupt file.</li>
<li><code>ireg</code>: Read and write data for indirect CSR access for this interrupt file.</li>
</ul>
<h3 id="‰∏≠Êñ≠Êñá‰ª∂ÁöÑÂÜÖÂ≠òÊò†Â∞ÑÂØÑÂ≠òÂô®interrupt-file-memory-mapped-registers"><a class="header" href="#‰∏≠Êñ≠Êñá‰ª∂ÁöÑÂÜÖÂ≠òÊò†Â∞ÑÂØÑÂ≠òÂô®interrupt-file-memory-mapped-registers">‰∏≠Êñ≠Êñá‰ª∂ÁöÑÂÜÖÂ≠òÊò†Â∞ÑÂØÑÂ≠òÂô®ÔºàInterrupt File Memory-mapped RegistersÔºâ</a></h3>
<p>ÊØè‰∏™‰∏≠Êñ≠Êñá‰ª∂ÂåÖÂê´‰∏Ä‰∏™4KBÂÜÖÂ≠òÈ°µÔºåÁî®‰∫éÊé•Êî∂Êù•Ëá™ÊÄªÁ∫ø/ÁΩëÁªúÁöÑÊ∂àÊÅØ„ÄÇ
ÂÜÖÂ≠òÈ°µÂÜÖ‰ªÖÂåÖÂê´‰∏Ä‰∏™4BÂÜÖÂ≠òÊò†Â∞ÑÂØÑÂ≠òÂô®:</p>
<ul>
<li><code>seteipnum</code>: ‰Ωç‰∫éÂÅèÁßªÈáè0x0Â§ÑÔºåÊé•Êî∂‰º†ÂÖ•ÁöÑ‰∏≠Êñ≠Âè∑„ÄÇ</li>
</ul>
<p>Each interrupt file includes a 4KB memory page for receiving messages from bus/network.
The memory page including only one 4B memory-mapped register:</p>
<ul>
<li><code>seteipnum</code>: Located at offset of 0x0, receiving incoming interrupt IDs.</li>
</ul>
<h3 id="‰∏≠Êñ≠Êñá‰ª∂ÂÜÖÈÉ®ÁöÑÂØÑÂ≠òÂô®interrupt-file-internal-registers"><a class="header" href="#‰∏≠Êñ≠Êñá‰ª∂ÂÜÖÈÉ®ÁöÑÂØÑÂ≠òÂô®interrupt-file-internal-registers">‰∏≠Êñ≠Êñá‰ª∂ÂÜÖÈÉ®ÁöÑÂØÑÂ≠òÂô®ÔºàInterrupt File Internal RegistersÔºâ</a></h3>
<p>ÊâÄÊúâ‰∏äËø∞Êé•Âè£ÈÉΩ‰∏é‰∏≠Êñ≠Êñá‰ª∂ÁöÑÂÜÖÈÉ®ÂØÑÂ≠òÂô®‰∫§‰∫í„ÄÇ
ÂÖ≥ÈîÆÁöÑÂÜÖÈÉ®ÂØÑÂ≠òÂô®ÂåÖÊã¨:</p>
<ul>
<li><code>eip[intSrcNum‰Ωç]</code>: Ë°®Á§∫ËØ•‰∏≠Êñ≠ÊòØÂê¶ÂæÖÂ§ÑÁêÜ„ÄÇ</li>
<li><code>eie[intSrcNum‰Ωç]</code>: Ë°®Á§∫ËØ•‰∏≠Êñ≠ÊòØÂê¶‰ΩøËÉΩ„ÄÇ</li>
</ul>
<p>Each interrupt file maintains internal registers that interact with the interfaces above.
The key internal registers consist of:</p>
<ul>
<li><code>eip[intSrcNum bits]</code>: Whether this interrupt is pending.</li>
<li><code>eie[intSrcNum bits]</code>: Whether this interrupt is enabled.</li>
</ul>
<h2 id="Â§ö‰∏™imsicÁöÑÁªÑÁªáÂΩ¢Âºèmultiple-imsics-arrangement"><a class="header" href="#Â§ö‰∏™imsicÁöÑÁªÑÁªáÂΩ¢Âºèmultiple-imsics-arrangement">Â§ö‰∏™IMSICÁöÑÁªÑÁªáÂΩ¢ÂºèÔºàMultiple IMSICs ArrangementÔºâ</a></h2>
<p>Âú®Â§ßÂûãÁ≥ªÁªü‰∏≠ÔºåÊ†∏-IMSICÂØπÂèØ‰ª•ÂàÜÊàêÂ§öÁªÑ„ÄÇ
‰∏ãÂõæÊòæÁ§∫‰∫Ü‰∏Ä‰∏™ÂØπÁß∞ÁöÑ4Ê†∏-IMSICÁ≥ªÁªü„ÄÇ
Ëøô4ÂØπË¢´ÂàÜ‰∏∫2<strong>ÁªÑ</strong>ÔºåÊØèÁªÑÂåÖÂê´2‰∏™<strong>ÊàêÂëò</strong>(hart-IMSICÂØπ)„ÄÇ</p>
<p>In a large system, hart-IMSIC pairs can be divided into groups.
The below figure shows a symmetric 4-hart-IMSIC system.
These 4 pairs are divided into 2 <strong>groups</strong>, and each group contains 2 <strong>members</strong> (hart-IMSIC pairs).</p>
<p><img src="./images/imsics_arrangement_py.svg" alt="" /></p>
<h3 id="imsicÂú∞ÂùÄÂ≠óÊÆµimsic-address-fields"><a class="header" href="#imsicÂú∞ÂùÄÂ≠óÊÆµimsic-address-fields">IMSICÂú∞ÂùÄÂ≠óÊÆµÔºàIMSIC Address FieldsÔºâ</a></h3>
<p>‰∏∫‰∫ÜÊîØÊåÅÁâ©ÁêÜÂÜÖÂ≠ò‰øùÊä§(physical memory protection, PMP)ÔºåÁõ∏ÂêåÁâπÊùÉÊÄÅÁöÑ‰∏≠Êñ≠Êñá‰ª∂‰Ωç‰∫éÂêå‰∏ÄÂÜÖÂ≠òÂå∫Âüü:</p>
<ul>
<li>Êú∫Âô®ÊÄÅÂÜÖÂ≠òÂå∫Âüü:
<ul>
<li>ÊØè‰∏™Â§ÑÁêÜÂô®Ê†∏ÂøÉÂØπÂ∫î‰∏Ä‰∏™Êú∫Âô®ÊÄÅ‰∏≠Êñ≠Êñá‰ª∂</li>
</ul>
</li>
<li>ÁõëÁÆ°ÊÄÅÂÜÖÂ≠òÂå∫Âüü:
<ul>
<li>ÊØè‰∏™Â§ÑÁêÜÂô®Ê†∏ÂøÉÂØπÂ∫î‰∏Ä‰∏™ÁõëÁÆ°ÊÄÅ‰∏≠Êñ≠Êñá‰ª∂,</li>
<li>ÊØè‰∏™Â§ÑÁêÜÂô®Ê†∏ÂøÉÂØπÂ∫îÂ§ö‰∏™ËôöÊãüÂåñÁõëÁÆ°ÊÄÅ‰∏≠Êñ≠Êñá‰ª∂„ÄÇ</li>
</ul>
</li>
</ul>
<p>To support physical memory protection (PMP), interrupt files of the same privilege level are located in a same memory region:</p>
<ul>
<li>Machine-level memory region:
<ul>
<li>One machine-level interrupt file per hart</li>
</ul>
</li>
<li>Supervisor-level memory region:
<ul>
<li>One supervisor-level interrupt file per hart,</li>
<li>Multiple virtualized supervisor-level interrupt files per hart.</li>
</ul>
</li>
</ul>
<p>Âõ†Ê≠§ÔºåÊØè‰∏™Â§ÑÁêÜÂô®Ê†∏ÂøÉÂú®Êú∫Âô®ÊÄÅÂÜÖÂ≠òÂå∫ÂüüÂè™Âç†‰∏ÄÈ°µÔºå‰ΩÜÂú®ÁõëÁÆ°ÊÄÅÂÜÖÂ≠òÂå∫ÂüüÂç†Â§öÈ°µÔºå
Áî±<strong>ÂÆ¢Êà∑Âè∑</strong>ÔºàÁõëÁÆ°ÊÄÅ‰∏∫0ÔºåËôöÊãüÂåñÁõëÁÆ°ÊÄÅ‰∏∫1„ÄÅ2„ÄÅ3„ÄÅ...)Á¥¢Âºï„ÄÇ
ÈúÄË¶ÅÂõõ‰∏™Â≠óÊÆµÊù•Á°ÆÂÆö‰∏Ä‰∏™IMSICÁöÑÂÜÖÂ≠òÈ°µÁöÑÂú∞ÂùÄÔºö</p>
<ul>
<li>ÁâπÊùÉÊÄÅÔºöÊú∫Âô®ÊÄÅÊàñÁõëÁÆ°ÊÄÅ„ÄÇ</li>
<li>ÁªÑÂè∑ÔºöËØ•IMSICÊâÄÂ±ûÁöÑÁªÑ„ÄÇ</li>
<li>ÊàêÂëòÂè∑ÔºöËØ•IMSICÊâÄÂ±ûÁöÑÊàêÂëò„ÄÇ</li>
<li>ÂÆ¢Êà∑Âè∑ÔºöÁõëÁÆ°ÊÄÅÊàñËôöÊãüÂåñÁõëÁÆ°ÊÄÅ‰πã‰∏Ä„ÄÇ</li>
</ul>
<p>Thus, each hart has only one page in machine-level memory region and multiple pages in supervisor-level memory region,
indexed by a <strong>guest ID</strong> (0 for supervisor-level, 1,2,3,... for virtualized supervisor level).
When determining the memory page address for a given IMSIC, four fields are needed:</p>
<ul>
<li>Privilege Level: Machine level or supervisor level.</li>
<li>Group ID: The group to which this IMSIC belongs.</li>
<li>Member ID: The member to which this IMSIC belongs.</li>
<li>Guest ID: Supervisor level or one of the virtualized supervisor levels.</li>
</ul>
<p><img src="./images/imsic_addr.svg" alt="" /></p>
<p>Êú∫Âô®ÊÄÅ‰∏≠Êñ≠Êñá‰ª∂ÁöÑÂú∞ÂùÄË°®ËææÂºè‰∏∫Ôºö</p>
<p>The formal expression for a machine-level interrupt file address:</p>
<p>$$
\begin{align}
mIntFileAddr =
&amp; mBaseAddr \\
&amp; + groupID \times 2^{mGroupStrideWidth} \\
&amp; + memberID \times 2^{mMemberStrideWidth} \\
&amp; + guestID \times 4K
\end{align}
$$</p>
<p>ËôöÊãüÂåñÁõëÁÆ°ÊÄÅ‰∏≠Êñ≠Êñá‰ª∂ÁöÑÂú∞ÂùÄË°®ËææÂºè‰∏∫Ôºö</p>
<p>The formal expression for a virtualized supervisor-level interrupt file address:</p>
<p>$$
\begin{align}
vsIntFileAddr =
&amp; vsBaseAddr \\
&amp; + groupID \times 2^{vsGroupStrideWidth} \\
&amp; + memberID \times 2^{vsMemberStrideWidth} \\
&amp; + guestID \times 4K
\end{align}
$$</p>
<p>ÊåâÁÖßAIAËßÑËåÉÁöÑË¶ÅÊ±ÇÔºå<code>vsGroupStrideWidth</code>‰∏é<code>mGroupStrideWidth</code>Áõ∏Âêå„ÄÇ
Êõ¥Â§öËØ¶ÁªÜ‰ø°ÊÅØÔºåËØ∑ÂèÇÈòÖAIAËßÑËåÉ<sup class="footnote-reference"><a href="#imsic_memory_region">1</a></sup>„ÄÇ</p>
<p>As required by the AIA specification, the <code>vsGroupStrideWidth</code> is the same as the <code>mGroupStrideWidth</code>.
For more details, please refer to the AIA specification<sup class="footnote-reference"><a href="#imsic_memory_region">1</a></sup>.</p>
<h3 id="imsicÂÜÖÂ≠òÂå∫Âüüimsic-memory-regions"><a class="header" href="#imsicÂÜÖÂ≠òÂå∫Âüüimsic-memory-regions">IMSICÂÜÖÂ≠òÂå∫ÂüüÔºàIMSIC Memory RegionsÔºâ</a></h3>
<p>Êú∫Âô®ÂíåÁõëÁÆ°ÊÄÅÁöÑÂÜÖÂ≠òÂå∫ÂüüÂ¶Ç‰∏ãÊâÄÁ§∫„ÄÇ</p>
<p>The memory regions for machine and supervisor levels are shown as below.</p>
<p><img src="./images/imsic_addr_space.svg" alt="" /></p>
<p>ËøôÈáåÂ±ïÁ§∫‰∏Ä‰∏™ÂÖ∑‰ΩìÁöÑ‰æãÂ≠ê„ÄÇ
ÂÅáËÆæÊú∫Âô®ÊÄÅÂíåÁõëÁÆ°ÊÄÅÁöÑÂÜÖÂ≠òÂå∫ÂüüÂü∫Âú∞ÂùÄÂàÜÂà´‰∏∫<code>0x6100_0000</code>Âíå<code>0x8290_0000</code>ÔºåÈÇ£‰πàÊØè‰∏™‰∏≠Êñ≠Êñá‰ª∂ÁöÑÂú∞ÂùÄ‰∏∫Ôºö</p>
<p>Here is a concrete example.
Assuming the base addresses for machine-level and supervisor-level memory regions are <code>0x6100_0000</code> and <code>0x8290_0000</code>, respectively,
the addresses for each interrupt file are:</p>
<ul>
<li>Machine-level interrupt files:
<ul>
<li>IMSIC00: <code>[0x61000000, 0x61000fff]</code></li>
<li>IMSIC01: <code>[0x61001000, 0x61001fff]</code></li>
<li>IMSIC10: <code>[0x61008000, 0x61008fff]</code></li>
<li>IMSIC11: <code>[0x61009000, 0x61009fff]</code></li>
</ul>
</li>
<li>Supervisor-level interrupt files:
<ul>
<li>IMSIC00: <code>[0x82900000, 0x82903fff]</code></li>
<li>IMSIC01: <code>[0x82904000, 0x82907fff]</code></li>
<li>IMSIC10: <code>[0x82908000, 0x8290bfff]</code></li>
<li>IMSIC11: <code>[0x8290c000, 0x8290ffff]</code></li>
</ul>
</li>
</ul>
<div class="footnote-definition" id="imsic_memory_region"><sup class="footnote-definition-label">1</sup>
<p>The RISC-V Advanced Interrupt Architecture: 3.6. Arrangement of the memory regions of multiple interrupt files</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aplic"><a class="header" href="#aplic">üß∂APLIC</a></h1>
<!-- vim-markdown-toc GFM -->
<ul>
<li><a href="aplic.html#%E5%9F%9Fdomain">ÂüüÔºàDomainÔºâ</a>
<ul>
<li><a href="aplic.html#%E5%86%85%E9%83%A8%E5%AF%84%E5%AD%98%E5%99%A8internal-registers">ÂÜÖÈÉ®ÂØÑÂ≠òÂô®ÔºàInternal RegistersÔºâ</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<p>Âú®Âü∫‰∫éÊ∂àÊÅØÁöÑ‰∏≠Êñ≠Ê®°Âºè‰∏ãÔºåAPLICÂ∞Ü‰º†ÁªüÁöÑÁ∫ø‰∏≠Êñ≠ËΩ¨Êç¢‰∏∫MSI„ÄÇ
‰∏∫‰∫ÜÊèêÈ´òÊïàÁéáÔºåÈô§ÈùûËÆæÂ§áÂú®Áâ©ÁêÜ‰∏äÊòØÂàÜÂºÄÁöÑÔºà‰æãÂ¶ÇÂú®‰∏çÂêåÁöÑËäØÁâáÁªÑ‰∏äÔºâÔºåÂçï‰∏™APLICÂÆû‰æãÂç≥ÂèØÊúçÂä°ÊâÄÊúâÂ§ÑÁêÜÂô®Ê†∏ÂøÉ„ÄÇ</p>
<p>In message-based interrupt mode, the APLIC converts traditional wired interrupts into MSIs.
For efficiency, a single APLIC instance should serve all harts, unless devices are physically separated (e.g. on different chiplets).</p>
<h2 id="Âüüdomain"><a class="header" href="#Âüüdomain">ÂüüÔºàDomainÔºâ</a></h2>
<p>APLICÂÆûÁé∞‰∫ÜÂàÜÂ±ÇÁöÑÂüüÁªìÊûÑÊù•ÁÆ°ÁêÜ‰∏çÂêåÁöÑÁâπÊùÉÊÄÅ:</p>
<ul>
<li>Ê†πÂüüÔºàÊú∫Âô®ÊÄÅÔºâÁõ¥Êé•Êé•Êî∂ÊâÄÁ∫ø‰∏≠Êñ≠,</li>
<li>Â≠êÂüü‰ªéÂÖ∂Áà∂ÂüüÊé•Êî∂ÂßîÊâòÁöÑ‰∏≠Êñ≠,</li>
<li>ÁõëÁÆ°ÊÄÅÂüüÂèØ‰ª•Â§ÑÁêÜÁõëÁÆ°ÊÄÅÂíåËôöÊãüÂåñÁõëÁÆ°ÊÄÅ‰∏≠Êñ≠„ÄÇ</li>
</ul>
<p>The APLIC implements a hierarchical domain structure to manage different privilege levels:</p>
<ul>
<li>The root domain (machine level) directly receives all wired interrupts,</li>
<li>Child domains receive delegated interrupts from their parent domains,</li>
<li>A supervisor-level domain can handle both supervisor-level and virtualized supervisor-level interrupts.</li>
</ul>
<p>ÂØπ‰∫éÂ§ßÂûãÂØπÁß∞Â§öÂ§ÑÁêÜÁ≥ªÁªüÔºåÈÄöÂ∏∏‰∏§‰∏™ÂüüÁöÑÈÖçÁΩÆÂ∞±Ë∂≥Â§ü‰∫ÜÔºö</p>
<ul>
<li>‰∏Ä‰∏™Êú∫Âô®ÊÄÅÂüü,</li>
<li>‰∏Ä‰∏™ÁõëÁÆ°ÊÄÅÂüü„ÄÇ</li>
</ul>
<p>For large symmetric multiprocessing systems, a two-domain configuration typically suffices:</p>
<ul>
<li>One machine-level domain,</li>
<li>One supervisor-level domain.</li>
</ul>
<p><img src="./images/aplic.svg" alt="" /></p>
<h3 id="ÂÜÖÈÉ®ÂØÑÂ≠òÂô®internal-registers"><a class="header" href="#ÂÜÖÈÉ®ÂØÑÂ≠òÂô®internal-registers">ÂÜÖÈÉ®ÂØÑÂ≠òÂô®ÔºàInternal RegistersÔºâ</a></h3>
<p>APLICÂú®ÂÜÖÈÉ®ÂØÑÂ≠òÂô®‰∏≠Áª¥Êä§‰∏≠Êñ≠Áä∂ÊÄÅÔºåÂåÖÊã¨‰∏§‰∏™ÂÖ≥ÈîÆÂØÑÂ≠òÂô®Ôºö</p>
<ul>
<li><code>ip[intSrcNum‰Ωç]</code>: ‰∏≠Êñ≠ÂæÖÂ§ÑÁêÜÁä∂ÊÄÅÂØÑÂ≠òÂô®,</li>
<li><code>ie[intSrcNum‰Ωç]</code>: ‰∏≠Êñ≠‰ΩøËÉΩÊéßÂà∂ÂØÑÂ≠òÂô®„ÄÇ</li>
</ul>
<p>APLIC maintains interrupt status in internal registers, including two critical registers:</p>
<ul>
<li><code>ip[intSrcNum bits]</code>: Interrupt pending status registers,</li>
<li><code>ie[intSrcNum bits]</code>: Interrupt enable control registers.</li>
</ul>
<p>Ëøô‰∫õÂØÑÂ≠òÂô®ÈÄöËøáÂÜÖÂ≠òÊò†Â∞ÑÊé•Âè£ËøõË°åÊéßÂà∂„ÄÇ
ÊúâÂÖ≥ËØ¶ÁªÜÁöÑÂØÑÂ≠òÂô®ËßÑËåÉÔºåËØ∑ÂèÇÈòÖAIAËßÑËåÉ<sup class="footnote-reference"><a href="#aplic_mem_regs">1</a></sup>„ÄÇ</p>
<p>These registers are controlled through memory-mapped interfaces.
For detailed register specifications, refer to the AIA specification<sup class="footnote-reference"><a href="#aplic_mem_regs">1</a></sup>.</p>
<p><strong>Á´û‰∫âÊù°‰ª∂</strong>Ôºà<strong>Race Conditions</strong>Ôºâ</p>
<p><code>ip</code>ÂØÑÂ≠òÂô®ÂèØ‰ª•Ë¢´Â§ö‰∏™Êù•Ê∫ê‰øÆÊîπÔºå‰ªéËÄå‰∫ßÁîüÊΩúÂú®ÁöÑÁ´û‰∫âÊù°‰ª∂„ÄÇ
AIAËßÑËåÉÊ≤°ÊúâËßÑÂÆöAPLICÂú®ËøôÁßçÁ´û‰∫âÊù°‰ª∂‰∏ãÁöÑË°å‰∏∫„ÄÇ
ChiselAIAÂÆûÁé∞‰∫Ü‰∏Ä‰∏™Âü∫‰∫é‰ºòÂÖàÁ∫ßÁöÑËß£ÂÜ≥Êú∫Âà∂„ÄÇ
‰ºòÂÖàÁ∫ß(‰ªéÈ´òÂà∞‰Ωé):</p>
<ul>
<li>APLICÂÜÖÈÉ®Êìç‰ΩúÔºöÂèëÈÄÅMSIÂêéÊ∏ÖÈô§<code>ip</code>Ôºå</li>
<li>Á∫øËÆæÂ§áÊìç‰ΩúÔºöÈÄöËøá<code>intSrc</code>ËÆæÁΩÆ<code>ip</code>Ôºå</li>
<li>Â§ÑÁêÜÂô®Ê†∏ÂøÉÊìç‰ΩúÔºöÈÄöËøáÂÜÖÂ≠òÊò†Â∞ÑÂØÑÂ≠òÂô®ËÆæÁΩÆ/Ê∏ÖÈô§<code>ip</code>„ÄÇ</li>
</ul>
<p>The <code>ip</code> registers can be modified by multiple sources, creating potential race conditions.
The AIA specification does not specify the APLIC behaviors under this race condition.
ChiselAIA implements a priority-based resolution mechanism.
Priority levels (highest to lowest):</p>
<ul>
<li>APLIC internal operations: Clearing <code>ip</code> after sending an MSI,</li>
<li>Wired device operations: Setting <code>ip</code> via <code>intSrc</code>,</li>
<li>Hart operations: Setting/Clearing <code>ip</code> via memory mapped registers.</li>
</ul>
<p>È´ò‰ºòÂÖàÁ∫ßÊìç‰Ωú‰ºöË¶ÜÁõñ‰Ωé‰ºòÂÖàÁ∫ßÊìç‰Ωú„ÄÇ
Êàë‰ª¨Êé®ËçêÈÄöËøáÁºñÁ®ãÁöÑÊñπÂºèÈÅøÂÖçÁ´û‰∫âÊù°‰ª∂Ôºö
Âú®ÈÄöËøáÂÜÖÂ≠òÊò†Â∞ÑÂØÑÂ≠òÂô®‰øÆÊîπÁõ∏Â∫îÁöÑ<code>ip</code>‰πãÂâçÔºåÊñ≠ÂºÄÁ∫øËÆæÂ§á„ÄÇ</p>
<p>Higher priority operations override the lower priority ones.
We recommend to avoid race conditions through programming:
detaching the wired device before modifying corresponding <code>ip</code> through memory-mapped registers.</p>
<div class="footnote-definition" id="aplic_mem_regs"><sup class="footnote-definition-label">1</sup>
<p>The RISC-V Advanced Interrupt Architecture: 4.5. Memory-mapped control region for an interrupt domain</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ÈõÜÊàêÊåáÂçóintegration-guide"><a class="header" href="#ÈõÜÊàêÊåáÂçóintegration-guide">üß≠ÈõÜÊàêÊåáÂçóÔºàIntegration GuideÔºâ</a></h1>
<!-- vim-markdown-toc GFM -->
<ul>
<li><a href="integration.html#%E6%A6%82%E8%A7%88overview">Ê¶ÇËßàÔºàOverviewÔºâ</a></li>
<li><a href="integration.html#%E5%8F%82%E6%95%B0parameters">ÂèÇÊï∞ÔºàParametersÔºâ</a>
<ul>
<li><a href="integration.html#imsicparams"><code>IMSICParams</code></a></li>
<li><a href="integration.html#aplicparams"><code>APLICParams</code></a></li>
</ul>
</li>
<li><a href="integration.html#%E5%AE%9E%E4%BE%8B%E5%8C%96instantiation">ÂÆû‰æãÂåñÔºàInstantiationÔºâ</a>
<ul>
<li><a href="integration.html#span-stylecolorred%E5%85%B3%E4%BA%8Ehartindexabout-hartindexspan"><span style="color:red;">ÂÖ≥‰∫éhartIndexÔºàAbout hartIndexÔºâ</span></a></li>
</ul>
</li>
<li><a href="integration.html#%E7%A4%BA%E4%BE%8Bexamples">Á§∫‰æãÔºàExamplesÔºâ</a>
<ul>
<li><a href="integration.html#%E7%AE%80%E5%8D%95%E7%9A%844%E6%A0%B8%E7%B3%BB%E7%BB%9Fa-simple-4-hart-system">ÁÆÄÂçïÁöÑ4Ê†∏Á≥ªÁªüÔºàA Simple 4-Hart SystemÔºâ</a></li>
<li><a href="integration.html#%E5%88%86%E7%BB%84%E7%9A%844%E6%A0%B8%E7%B3%BB%E7%BB%9Fa-grouped-4-hart-system">ÂàÜÁªÑÁöÑ4Ê†∏Á≥ªÁªüÔºàA Grouped 4-Hart SystemÔºâ</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<p>Êú¨ÊåáÂçó‰ªãÁªçÂ¶Ç‰ΩïÂ∞ÜChiselAIAÈõÜÊàêÂà∞RISC-VÁ≥ªÁªü‰∏≠„ÄÇ</p>
<p>This guide introduces the integration process of ChiselAIA into a RISC-V system.</p>
<h2 id="Ê¶ÇËßàoverview"><a class="header" href="#Ê¶ÇËßàoverview">Ê¶ÇËßàÔºàOverviewÔºâ</a></h2>
<p>ÈõÜÊàêÊ∂âÂèä2‰∏™ScalaÊñá‰ª∂ÔºåÂÖ±4‰∏™ScalaÁ±ªÔºö</p>
<ul>
<li><code>APLIC.scala</code>Ôºö
<ul>
<li><code>APLICParams</code>ÔºöÁî®‰∫éÈÖçÁΩÆAPLICÂÆû‰æãÁöÑÂèÇÊï∞Á±ª</li>
<li><code>APLIC</code>ÔºöAPLICÊ®°ÂùóÁöÑÊ†∏ÂøÉÈÄªËæë</li>
<li>ÊØè‰∏™Á≥ªÁªüÈúÄË¶Å‰∏Ä‰∏™ÂÆû‰æãÔºö
<ul>
<li><code>TLAPLIC</code>ÔºöÂØπ<code>APLIC</code>Ê®°ÂùóÁöÑTilelinkÂçèËÆÆÂåÖË£Ö</li>
<li><code>AXI4APLIC</code>ÔºöÂØπ<code>APLIC</code>Ê®°ÂùóÁöÑAXI4ÂçèËÆÆÂåÖË£Ö</li>
</ul>
</li>
</ul>
</li>
<li><code>IMSIC.scala</code>Ôºö
<ul>
<li><code>IMSICParams</code>ÔºöÁî®‰∫éÈÖçÁΩÆIMSICÂÆû‰æãÁöÑÂèÇÊï∞Á±ª</li>
<li><code>IMSIC</code>ÔºöIMSICÊ®°ÂùóÁöÑÊ†∏ÂøÉÈÄªËæë</li>
<li>ÊØè‰∏™Â§ÑÁêÜÂô®Ê†∏ÂøÉÈúÄË¶Å‰∏Ä‰∏™ÂÆû‰æãÔºö
<ul>
<li><code>TLIMSIC</code>ÔºöÂØπ<code>IMSIC</code>Ê®°ÂùóÁöÑTilelinkÂçèËÆÆÂåÖË£Ö</li>
<li><code>AXI4IMSIC</code>ÔºöÂØπ<code>IMSIC</code>Ê®°ÂùóÁöÑAXI4ÂçèËÆÆÂåÖË£Ö</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Integration involves 2 scala files, including 4 scala classes:</p>
<ul>
<li><code>APLIC.scala</code>:
<ul>
<li><code>APLICParams</code>: Parameter classes for configuring APLIC instance.</li>
<li><code>APLIC</code>: The main logic of APLIC module.</li>
<li>Requiring one instance per system:
<ul>
<li><code>TLAPLIC</code>: The <code>APLIC</code> module wrapped by Tilelink protocol,</li>
<li><code>AXI4APLIC</code>: The <code>APLIC</code> module wrapped by AXI4 protocol.</li>
</ul>
</li>
</ul>
</li>
<li><code>IMSIC.scala</code>:
<ul>
<li><code>IMSICParams</code>: Parameter classes for configuring IMSIC instances.</li>
<li><code>IMSIC</code>: The main logic of IMSIC module.</li>
<li>Requiring one instance per hart:
<ul>
<li><code>TLIMSIC</code>: The <code>IMSIC</code> module wrapped by Tilelink protocol,</li>
<li><code>AXI4IMSIC</code>: The <code>IMSIC</code> module wrapped by AXI4 protocol.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="images/integration_files.svg" alt="" /></p>
<h2 id="ÂèÇÊï∞parameters"><a class="header" href="#ÂèÇÊï∞parameters">ÂèÇÊï∞ÔºàParametersÔºâ</a></h2>
<p>Êú¨ËäÇÊ¶ÇËø∞‰∫ÜAPLICÂíåIMSICÁöÑÂèØÈÖçÁΩÆÂèÇÊï∞„ÄÇ
ËôΩÁÑ∂Êèê‰æõ‰∫ÜÈªòËÆ§ÂÄºÔºå‰ΩÜÊàë‰ª¨Âº∫ÁÉàÂª∫ËÆÆÊ†πÊçÆÂÖ∑‰ΩìÁöÑÈõÜÊàêÈúÄÊ±ÇÔºåËá™ÂÆö‰πâÂ∏¶ÊúâüëâÊ†áËÆ∞ÁöÑÂèÇÊï∞„ÄÇ
ÂÖ∂‰ªñÂèÇÊï∞Ë¶Å‰πàÊòØÊ¥æÁîüÁöÑÔºåË¶Å‰πàÊòØÁ°¨ÁºñÁ†ÅÁöÑÔºàËØ¶ÊÉÖÂèÇËßÅ<code>Params.scala</code>Ôºâ„ÄÇ</p>
<p>This section outlines the configurable parameters for APLIC and IMSIC.
While defaul values are provided,
we strongly recommend customizing parameters marked with üëâ to suit your specific integration needs.
Other parameters are either derived or hard-coded, (see <code>Params.scala</code> for details).</p>
<p>ÂëΩÂêçÁ∫¶ÂÆöÔºö</p>
<ul>
<li><code>Num</code>ÂêéÁºÄÔºöÊüêÂÆû‰ΩìÁöÑÊï∞ÈáèÔºå</li>
<li><code>Width</code>ÂêéÁºÄÔºöÊüêÂÆû‰ΩìÁöÑ‰ΩçÂÆΩÔºàÈÄöÂ∏∏ÊòØ<code>log2(ÂÆû‰ΩìÊï∞Èáè)</code>ÔºâÔºå</li>
<li><code>Addr</code>ÂêéÁºÄÔºöÊüêÂÆû‰ΩìÁöÑÂú∞ÂùÄ„ÄÇ</li>
</ul>
<p>Naming conventions:</p>
<ul>
<li><code>Num</code> suffix: Number of the items.</li>
<li><code>Width</code> suffix: Bit width of an item (typically <code>log2(number of the item)</code>).</li>
<li><code>Addr</code> suffix: Address of an item.</li>
</ul>
<h3 id="imsicparams"><a class="header" href="#imsicparams"><code>IMSICParams</code></a></h3>
<pre><code class="language-scala">package aia

import chisel3._
import chisel3.IO
import chisel3.util._
import freechips.rocketchip.amba.axi4._
import freechips.rocketchip.amba.axi4.AXI4Xbar
import freechips.rocketchip.devices.tilelink._
import freechips.rocketchip.diplomacy._
import freechips.rocketchip.prci.ClockSinkDomain
import freechips.rocketchip.regmapper._
import freechips.rocketchip.tilelink._
import freechips.rocketchip.util._
import org.chipsalliance.cde.config.Parameters
import utility._

object RegMapDV {
  def Unwritable = null
  def apply(addr: Int, reg: UInt, wfn: UInt =&gt; UInt = (x =&gt; x)) = (addr, (reg, wfn))
  def generate(
      default: UInt,
      mapping: Map[Int, (UInt, UInt =&gt; UInt)],
      raddr:   UInt,
      rvld:    Bool,
      rdata:   UInt,
      rvalid:  Bool,
      waddr:   UInt,
      wen:     Bool,
      wdata:   UInt,
      wmask:   UInt,
      illegal_priv: Bool,
      illegal_op:   Bool
  ): Unit = {
    val chiselMapping = mapping.map { case (a, (r, w)) =&gt; (a.U, r, w) }
    when(rvld) {
      rdata := LookupTreeDefault(
        raddr,
        Cat(default),
        chiselMapping.map { case (a, r, _) =&gt; (a, r) }
      )
      rvalid := true.B
    }.otherwise {
      rdata  := 0.U((rdata.getWidth).W)
      rvalid := illegal_priv | illegal_op
    }

    chiselMapping.foreach { case (a, r, w) =&gt;
      if (w != null) {
        when(wen &amp;&amp; waddr === a &amp;&amp; !illegal_priv &amp;&amp; !illegal_op) {
          r := w(MaskData(r, wdata, wmask))
        }
      }
    }
  }
  def generate(
      default: UInt,
      mapping: Map[Int, (UInt, UInt =&gt; UInt)],
      addr:    UInt,
      rvld:    Bool,
      rdata:   UInt,
      rvalid:  Bool,
      wen:     Bool,
      wdata:   UInt,
      wmask:   UInt,
      illegal_priv: Bool,
      illegal_wdata_op:   Bool
  ): Unit = generate(default, mapping, addr, rvld, rdata, rvalid, addr, wen, wdata, wmask, illegal_priv, illegal_wdata_op)
}

// Based on Xiangshan NewCSR
object OpType extends ChiselEnum {
  val ILLEGAL = Value(0.U)
  val CSRRW   = Value(1.U)
  val CSRRS   = Value(2.U)
  val CSRRC   = Value(3.U)
}
object PrivType extends ChiselEnum {
  val U = Value(0.U)
  val S = Value(1.U)
  val H = Value(2.U)
  val M = Value(3.U)
}
class MSITransBundle(params: IMSICParams) extends Bundle {
  val vld_req = Input(Bool()) // request from axireg
  val data = Input(UInt(params.MSI_INFO_WIDTH.W))
  val vld_ack = Output(Bool())  // ack for axireg from imsic. which indicates imsic can work actively.
}
class ForCVMBundle extends Bundle {
  val cmode = Input(Bool()) // add port: cpu mode is tee or ree
  val notice_pending =
    Output(Bool()) // add port: interrupt pending of ree when cmode is tee,else interrupt pending of tee.
}
class AddrBundle(params: IMSICParams) extends  Bundle {
  val valid = Bool()                      // Ë°®Á§∫ addr ÊòØÂê¶ÊúâÊïà
  val bits  = new Bundle {
    val addr = UInt(params.iselectWidth.W) // Â≠òÂÇ®ÂÆûÈôÖÂú∞ÂùÄÂÄº
    val virt  = Bool()
    val priv  = PrivType()
  }
}
class CSRToIMSICBundle(params: IMSICParams) extends Bundle {
  val addr  = new AddrBundle(params)
  val vgein = UInt(params.vgeinWidth.W)
  val wdata = ValidIO(new Bundle {
    val op   = OpType()
    val data = UInt(params.xlen.W)
  })
  val claims = Vec(params.privNum, Bool())
}
class IMSICToCSRBundle(params: IMSICParams) extends Bundle {
  val rdata    = ValidIO(UInt(params.xlen.W))
  val illegal  = Bool()
  val pendings = UInt(params.intFilesNum.W)
  val topeis   = Vec(params.privNum, UInt(32.W))
}
case class IMSICParams(
    // MC IMSIC‰∏≠Êñ≠Ê∫êÊï∞ÈáèÁöÑÂØπÊï∞ÔºåÈªòËÆ§ÂÄº8Ë°®Á§∫IMSICÊîØÊåÅÊúÄÂ§ö512Ôºà2^9Ôºâ‰∏™‰∏≠Êñ≠Ê∫ê

    // MC ÔºàLogarithm of number of interrupt sources to IMSIC.
    // MC The default 9 means IMSIC support at most 256 (2^9) interrupt sourcesÔºâ:
    // MC{visible}
    imsicIntSrcWidth: Int = 9,
    // MC üëâ Êú¨IMSICÁöÑÊú∫Âô®ÊÄÅ‰∏≠Êñ≠Êñá‰ª∂ÁöÑÂú∞ÂùÄÔºàAddress of machine-level interrupt files for this IMSICÔºâÔºö
    mAddr: Long = 0x00000L,
    // MC üëâ Êú¨IMSICÁöÑÁõëÁÆ°ÊÄÅÂíåÂÆ¢Êà∑ÊÄÅ‰∏≠Êñ≠Êñá‰ª∂ÁöÑÂú∞ÂùÄÔºàAddr for supervisor-level and guest-level interrupt files for this IMSICÔºâ:
    sgAddr: Long = 0x10000L,
    // MC üëâ ÂÆ¢Êà∑‰∏≠Êñ≠Êñá‰ª∂ÁöÑÊï∞ÈáèÔºàNumber of guest interrupt filesÔºâ:
    geilen: Int = 7,
    // MC vgein‰ø°Âè∑ÁöÑ‰ΩçÂÆΩÔºàThe width of the vgein signalÔºâ:
    vgeinWidth: Int = 6,
    // MC iselect‰ø°Âè∑ÁöÑ‰ΩçÂÆΩ(The width of iselect signal):
    iselectWidth:           Int = 12,
    EnableImsicAsyncBridge: Boolean = true,
    HasTEEIMSIC:            Boolean = false
    // MC{hide}
) {
  lazy val xlen: Int = 64 // currently only support xlen = 64
  lazy val xlenWidth = log2Ceil(xlen)
  require(
    imsicIntSrcWidth &lt;= 11 &amp;&amp; imsicIntSrcWidth &gt;= 6,
    f"imsicIntSrcWidth=${imsicIntSrcWidth}, must not greater than log2(2048)=11, as there are at most 2048 eip/eie bits" +
      "must not be less than log2(64)=6, as there must be at least 64 eip/eie bits"
  )
  lazy val privNum:     Int = 3          // number of privilege modes: machine, supervisor, virtualized supervisor
  lazy val intFilesNum: Int = 2 + geilen // number of interrupt files, m, s, vs0, vs1, ...

  lazy val eixNum: Int = pow2(imsicIntSrcWidth).toInt / xlen // number of eip/eie registers
  lazy val intFileMemWidth: Int = 12 // interrupt file memory region width: 12-bit width =&gt; 4KB size
  require(vgeinWidth &gt;= log2Ceil(geilen))
  require(
    iselectWidth &gt;= 8,
    f"iselectWidth=${iselectWidth} needs to be able to cover addr [0x70, 0xFF], that is from CSR eidelivery to CSR eie63"
  )
  lazy val INTP_FILE_WIDTH = log2Ceil(intFilesNum)
  lazy val MSI_INFO_WIDTH  = imsicIntSrcWidth + INTP_FILE_WIDTH
}

class IMSIC(
    params:    IMSICParams,
    beatBytes: Int = 4
)(implicit p: Parameters) extends Module {
  println(f"IMSICParams.geilen:            ${params.geilen}%d")

  class IMSICGateWay extends Module {
    // === io port define ===
    val msiio = IO(new MSITransBundle(params))
    val msi_data_o  = IO(Output(UInt(params.imsicIntSrcWidth.W)))
    val msi_valid_o = IO(Output(UInt(params.intFilesNum.W)))

    // === main body ===
    val msi_in = Wire(UInt(params.MSI_INFO_WIDTH.W))
    msi_in := msiio.data
    val msi_vld_req_cpu = WireInit(false.B)
    when(params.EnableImsicAsyncBridge.B) {
      msi_vld_req_cpu := AsyncResetSynchronizerShiftReg(msiio.vld_req, 3, 0)
    }.otherwise {
      msi_vld_req_cpu := msiio.vld_req
    }
    val msi_vld_ack_cpu = RegInit(false.B)
    when(msi_vld_req_cpu)(
      msi_vld_ack_cpu := true.B
    ).otherwise(
      msi_vld_ack_cpu := false.B
    )
    // generate the msi_vld_ack,to handle with the input msi request.
    msiio.vld_ack := msi_vld_ack_cpu
    val msi_vld_ris_cpu = msi_vld_req_cpu &amp; (~msi_vld_ack_cpu) // rising of msi_vld_req
    val msi_data_catch  = RegInit(0.U(params.imsicIntSrcWidth.W))
    val msi_intf_valids = RegInit(0.U(params.intFilesNum.W))
    msi_data_o  := msi_data_catch(params.imsicIntSrcWidth - 1, 0)
    msi_valid_o := msi_intf_valids // multi-bis switch vector
    when(msi_vld_ris_cpu) {
      msi_data_catch := msi_in(params.imsicIntSrcWidth - 1, 0)
      msi_intf_valids := 1.U &lt;&lt; msi_in(params.MSI_INFO_WIDTH - 1,params.imsicIntSrcWidth)
    }.otherwise {
      msi_intf_valids := 0.U
    }
  }
  class IntFile extends Module {
    override def desiredName = "IntFile"
    val fromCSR = IO(Input(new Bundle {
      val seteipnum = ValidIO(UInt(params.imsicIntSrcWidth.W))
      val addr      = ValidIO(UInt(params.iselectWidth.W))
      val virt      = Bool()
      val priv      = PrivType()
      val vgein     = UInt(params.vgeinWidth.W)
      val wdata = ValidIO(new Bundle {
        val op   = OpType()
        val data = UInt(params.xlen.W)
      })
      val claim = Bool()
    }))
    val toCSR = IO(Output(new Bundle {
      val rdata   = ValidIO(UInt(params.xlen.W))
      val illegal = Bool()
      val pending = Bool()
      val topei   = UInt(params.imsicIntSrcWidth.W)
    }))
    val illegal_io = IO(new Bundle {
      val illegal_priv = Input(Bool())
    })
    val illegal_priv = illegal_io.illegal_priv
  
    /// indirect CSRs
    val eidelivery  = RegInit(0.U(params.xlen.W))
    val eithreshold = RegInit(0.U(params.xlen.W))
    val eips        = RegInit(VecInit.fill(params.eixNum)(0.U(params.xlen.W)))
    val eies        = RegInit(VecInit.fill(params.eixNum)(0.U(params.xlen.W)))

    val illegal_wdata_op = WireDefault(false.B)
    locally { // scope for xiselect CSR reg map
      val wdata = WireDefault(0.U(params.xlen.W))
      val wmask = WireDefault(0.U(params.xlen.W))
      when(fromCSR.wdata.valid) {
        switch(fromCSR.wdata.bits.op) {
          // is(OpType.ILLEGAL) {
          //   illegal_wdata_op := true.B
          // }
          is(OpType.CSRRW) {
            wdata := fromCSR.wdata.bits.data
            wmask := Fill(params.xlen, 1.U)
          }
          is(OpType.CSRRS) {
            wdata := Fill(params.xlen, 1.U)
            wmask := fromCSR.wdata.bits.data
          }
          is(OpType.CSRRC) {
            wdata := 0.U
            wmask := fromCSR.wdata.bits.data
          }
        }
      }
      def bit0ReadOnlyZero(x: UInt): UInt = x &amp; ~1.U(x.getWidth.W)
      def fixEIDelivery(x: UInt): UInt = x &amp; 1.U
      RegMapDV.generate(
        0.U,
        Map(
          RegMapDV(0x70, eidelivery, fixEIDelivery),
          RegMapDV(0x72, eithreshold),
          RegMapDV(0x80, eips(0), bit0ReadOnlyZero),
          RegMapDV(0xc0, eies(0), bit0ReadOnlyZero)
        ) ++ eips.drop(1).zipWithIndex.map { case (eip: UInt, i: Int) =&gt;
          RegMapDV(0x82 + i * 2, eip)
        } ++ eies.drop(1).zipWithIndex.map { case (eie: UInt, i: Int) =&gt;
          RegMapDV(0xc2 + i * 2, eie)
        },
        /*raddr*/  fromCSR.addr.bits,
        /*rvld */  fromCSR.addr.valid,
        /*rdata*/  toCSR.rdata.bits,
        /*rvalid*/ toCSR.rdata.valid,
        /*waddr*/  fromCSR.addr.bits,
        /*wen  */  fromCSR.wdata.valid,
        /*wdata*/  wdata,
        /*wmask*/  wmask,
        /*priv*/   illegal_priv,
        /*op*/     illegal_wdata_op
      )
      val illegal_csr = WireDefault(false.B)
      when(fromCSR.addr.bits &gt;= 0x80.U &amp;&amp; fromCSR.addr.bits &lt;= 0xFF.U &amp;&amp;
        fromCSR.addr.bits(0) === 1.U) {
          illegal_csr := true.B
      }
      toCSR.illegal := illegal_csr
    }
    locally {
      val index  = fromCSR.seteipnum.bits(params.imsicIntSrcWidth - 1, params.xlenWidth)
      val offset = fromCSR.seteipnum.bits(params.xlenWidth - 1, 0)
      when(fromCSR.seteipnum.valid) {
        // set eips bit
        eips(index) := eips(index) | UIntToOH(offset)
      }
    }

    locally { // scope for xtopei
      // The ":+ true.B" trick explain:
      //  Append true.B to handle the cornor case, where all bits in eip and eie are disabled.
      //  If do not append true.B, then we need to check whether the eip &amp; eie are empty,
      //  otherwise, the returned topei will become the max index, that is 2^intSrcWidth-1
      // Noted: the support max interrupt sources number = 2^intSrcWidth
      //              [0,     2^intSrcWidth-1] :+ 2^intSrcWidth
      val eipBools = Cat(eips.reverse).asBools :+ true.B
      val eieBools = Cat(eies.reverse).asBools :+ true.B
      
      def xtopei_filter(xeidelivery: UInt, xeithreshold: UInt, xtopei: UInt): UInt = {
        val tmp_xtopei = Mux(xeidelivery(params.xlen - 1, 1) === 0.U, Mux(xeidelivery(0), xtopei, 0.U) , 0.U)
        // {
        //   all interrupts are enabled, when eithreshold == 1;
        //   interrupts, when i &lt; eithreshold, are enabled;
        // } &lt;=&gt; interrupts, when i &lt;= (eithreshold -1), are enabled
        Mux(tmp_xtopei &lt;= (xeithreshold - 1.U), tmp_xtopei, 0.U)
      }
      toCSR.topei := xtopei_filter(
        eidelivery,
        eithreshold,
        ParallelPriorityMux(
          (eipBools zip eieBools).zipWithIndex.map {
            case ((p: Bool, e: Bool), i: Int) =&gt; (p &amp; e, i.U)
          }
        )
      )
    } // end of scope for xtopei
    toCSR.pending := toCSR.topei =/= 0.U

    when(fromCSR.claim) {
      val index  = toCSR.topei(params.imsicIntSrcWidth - 1, params.xlenWidth)
      val offset = toCSR.topei(params.xlenWidth - 1, 0)
      // clear the pending bit indexed by xtopei in xeip
      eips(index) := eips(index) &amp; ~UIntToOH(offset)
    }
  }
  val toCSR   = IO(Output(new IMSICToCSRBundle(params)))
  val fromCSR = IO(Input(new CSRToIMSICBundle(params)))
  val msiio   = IO(new MSITransBundle(params))
  val illegal_priv = WireInit(false.B)

  private val intFilesSelOH_r = WireDefault(0.U(params.intFilesNum.W))
  private val intFilesSelOH_w = WireDefault(0.U(params.intFilesNum.W))
  locally {
    when (fromCSR.addr.valid)
    {
      when(fromCSR.addr.bits.virt === false.B )
      {
        when(((fromCSR.addr.bits.priv.asUInt === 3.U) || (fromCSR.addr.bits.priv.asUInt === 1.U))/* &amp;&amp; fromCSR.vgein === 0.U*/){
          illegal_priv := false.B
        }.otherwise{
          illegal_priv := true.B
        }
      }.otherwise{
        when(fromCSR.addr.bits.priv.asUInt === 1.U &amp;&amp; (fromCSR.vgein &gt;= 1.U) &amp;&amp; (fromCSR.vgein &lt; (params.geilen + 1).U((params.vgeinWidth+1).W)))
        {
          illegal_priv := false.B
        }.otherwise{
          illegal_priv := true.B
        }
      }
    }
    when (fromCSR.addr.valid &amp;&amp; !illegal_priv) // read
    {
      val pv = Cat(fromCSR.addr.bits.priv.asUInt, fromCSR.addr.bits.virt)
      when(pv === Cat(PrivType.M.asUInt, false.B)){intFilesSelOH_r := UIntToOH(0.U)}
        .elsewhen(pv === Cat(PrivType.S.asUInt, false.B)){intFilesSelOH_r := UIntToOH(1.U)}
        .elsewhen(pv === Cat(PrivType.S.asUInt, true.B)){intFilesSelOH_r := UIntToOH(1.U((fromCSR.vgein.getWidth+1).W)
         + fromCSR.vgein.pad(params.vgeinWidth+1))
      }
    }
    when (fromCSR.addr.valid &amp;&amp; fromCSR.wdata.valid &amp;&amp; !(fromCSR.wdata.bits.op.asUInt === 0.U) &amp;&amp; !illegal_priv) // write
    {
        val pv = Cat(fromCSR.addr.bits.priv.asUInt, fromCSR.addr.bits.virt)
        when(pv === Cat(PrivType.M.asUInt, false.B)){intFilesSelOH_w := UIntToOH(0.U)}
        .elsewhen(pv === Cat(PrivType.S.asUInt, false.B)){intFilesSelOH_w := UIntToOH(1.U)}
        .elsewhen(pv === Cat(PrivType.S.asUInt, true.B)){intFilesSelOH_w := UIntToOH(1.U((fromCSR.vgein.getWidth+1).W)
         + fromCSR.vgein.pad(params.vgeinWidth+1))
        }
    }
  }

  private val topeis_forEachIntFiles   = Wire(Vec(params.intFilesNum, UInt(params.imsicIntSrcWidth.W)))
  private val illegals_forEachIntFiles = Wire(Vec(params.intFilesNum, Bool()))
  // instance and connect IMSICGateWay.
  val imsicGateWay = Module(new IMSICGateWay)
  imsicGateWay.msiio &lt;&gt; msiio
  val pendings = Wire(Vec(params.intFilesNum,Bool()))
  val vec_rdata = Wire(Vec(params.intFilesNum, ValidIO(UInt(params.xlen.W))))
  Seq(1, 1 + params.geilen).zipWithIndex.map {
    case (intFilesNum: Int, i: Int) =&gt; {
      // j: index for S intFile: S, G1, G2, ...
      val maps = (0 until intFilesNum).map { j =&gt;
        val flati = i + j
        val pi    = if (flati &gt; 2) 2 else flati // index for privileges: M, S, VS.

        def sel_addr(old: AddrBundle): AddrBundle = {
          val new_ = Wire(new AddrBundle(params))
          new_.valid := old.valid &amp; intFilesSelOH_r(flati)
          new_.bits.addr := old.bits.addr
          new_.bits.virt := old.bits.virt
          new_.bits.priv := old.bits.priv
          new_
        }
        def sel_wdata[T &lt;: Data](old: Valid[T]): Valid[T] = {
          val new_ = Wire(Valid(chiselTypeOf(old.bits)))
          new_.bits  := old.bits
          new_.valid := old.valid &amp; intFilesSelOH_w(flati)
          new_
        }

        val intFile = Module(new IntFile)
        // Preventing overflow
        when (flati.U((params.vgeinWidth + 1).W) === fromCSR.vgein.pad(params.vgeinWidth + 1)+1.U) {
          intFile.fromCSR.vgein := fromCSR.vgein
        } .otherwise {
          intFile.fromCSR.vgein := 0.U
        }
        val intfile_rdata_d = RegNext(intFile.toCSR.rdata)
        val msi_valid_delayed = RegNext(imsicGateWay.msi_valid_o(flati), false.B)
        intFile.fromCSR.seteipnum.bits  := imsicGateWay.msi_data_o
        intFile.fromCSR.seteipnum.valid := imsicGateWay.msi_valid_o(flati) | msi_valid_delayed
        intFile.fromCSR.addr.valid      := sel_addr(fromCSR.addr).valid
        intFile.fromCSR.addr.bits       := sel_addr(fromCSR.addr).bits.addr
        intFile.fromCSR.virt            := sel_addr(fromCSR.addr).bits.virt
        intFile.fromCSR.priv            := sel_addr(fromCSR.addr).bits.priv
        intFile.fromCSR.wdata           := sel_wdata(fromCSR.wdata)
        intFile.fromCSR.claim           := fromCSR.claims(pi)
        intFile.illegal_io.illegal_priv := illegal_priv
        vec_rdata(flati)                := intfile_rdata_d
        pendings(flati)                 := intFile.toCSR.pending
        topeis_forEachIntFiles(flati)   := intFile.toCSR.topei
        illegals_forEachIntFiles(flati) := intFile.toCSR.illegal
      }
    }
  }
  toCSR.rdata.valid   := vec_rdata.map(_.valid).reduce(_|_)
  toCSR.rdata.bits    := vec_rdata.map(_.bits).reduce(_|_)
  toCSR.pendings := (pendings.zipWithIndex.map{case (p,i) =&gt; p &lt;&lt; i.U}).reduce(_ | _) //vector -&gt; multi-bit
  locally {
    // Format of *topei:
    // * bits 26:16 Interrupt identity
    // * bits 10:0 Interrupt priority (same as identity)
    // * All other bit positions are zeros.
    // For detailed explainations of these memory region arguments,
    // please refer to the manual *The RISC-V Advanced Interrupt Architeture*: 3.9. Top external interrupt CSRs
    def wrap(topei: UInt): UInt = {
      val zeros = 0.U((16 - params.imsicIntSrcWidth).W)
      Cat(zeros, topei, zeros, topei)
    }
    val pv = Cat(fromCSR.addr.bits.priv.asUInt, fromCSR.addr.bits.virt)
    toCSR.topeis(0) := wrap(topeis_forEachIntFiles(0)) // m
    toCSR.topeis(1) := wrap(topeis_forEachIntFiles(1)) // s
    toCSR.topeis(2) := wrap(ParallelMux(
      UIntToOH(fromCSR.vgein - 1.U, params.geilen).asBools,
      topeis_forEachIntFiles.drop(2)
    )) // vs
  }  
  val toCSR_illegal_d = RegNext((fromCSR.addr.valid | fromCSR.wdata.valid) &amp; Seq(
    illegals_forEachIntFiles.reduce(_ | _),
    (fromCSR.wdata.valid &amp;&amp; fromCSR.wdata.bits.op.asUInt === 0.U),
    illegal_priv
  ).reduce(_ | _))
  toCSR.illegal := toCSR_illegal_d
}

//define IMSIC_WRAP: instance one imsic when HasCVMExtention is supported, else instance two imsic modules.
class IMSIC_WRAP(
    params:    IMSICParams,
    beatBytes: Int = 4
)(implicit p: Parameters) extends Module {
  // define the ports
  val toCSR   = IO(Output(new IMSICToCSRBundle(params)))
  val fromCSR = IO(Input(new CSRToIMSICBundle(params)))
  val msiio = IO(new MSITransBundle(params))
  // define additional ports when HasCVMExtention is supported.
  val sec = if (params.HasTEEIMSIC) Some(IO(new ForCVMBundle()))
  else None // include cmode input port,and o_notice_pending output port.
  val teemsiio = if (params.HasTEEIMSIC) Some(IO(new MSITransBundle(params))) else None
  // instance module,and body logic
  private val imsic = Module(new IMSIC(params, beatBytes))
  imsic.fromCSR := fromCSR
  toCSR         := imsic.toCSR
  imsic.msiio &lt;&gt; msiio
  // define additional logic for sec extention
  // .foreach logic only happens when sec is not none.
  sec.foreach { secIO =&gt;
    // get the sec.mode, connect sec.o_notice_pending to top.
    val cmode          = Wire(Bool())
    val notice_pending = Wire(Bool())
    cmode                := secIO.cmode
    secIO.notice_pending := notice_pending

    // instance tee imsic module.
    val teeimsic = Module(new IMSIC(params, beatBytes))
    teemsiio.foreach(teemsiio =&gt; teeimsic.msiio &lt;&gt; teemsiio)
    toCSR.rdata   := Mux(cmode, teeimsic.toCSR.rdata, imsic.toCSR.rdata) // toCSR needs to the selected depending cmode.
    toCSR.illegal := Mux(cmode, teeimsic.toCSR.illegal, imsic.toCSR.illegal)
    val s_pendings = Mux(cmode, teeimsic.toCSR.pendings(params.intFilesNum-1,1), imsic.toCSR.pendings(params.intFilesNum-1,1))
    val m_pendings = imsic.toCSR.pendings(0) // machine mode only from imsic.
    toCSR.pendings := Cat(s_pendings,m_pendings)
    //  toCSR.pendings := VecInit((0 until params.intFilesNum).map(i =&gt; pendings(i))) // uint-&gt;vector
    
    toCSR.topeis    := Mux(cmode, teeimsic.toCSR.topeis, imsic.toCSR.topeis)
    toCSR.topeis(0) := imsic.toCSR.topeis(0) // machine mode only from imsic.
    // to get the o_notice_pending, excluding the machine interrupt
//    val s_orpend_ree = imsic.toCSR.pendings.slice(1, params.intFilesNum) // extract the | of vector(1,N-1)
//    val s_orpend_tee = teeimsic.toCSR.pendings.slice(1, params.intFilesNum)
//    notice_pending := Mux(cmode, s_orpend_ree.reduce(_ | _), s_orpend_tee.reduce(_ | _))
    val s_orpend_ree = imsic.toCSR.pendings(params.intFilesNum-1,1) // extract the | of vector(1,N-1)
    val s_orpend_tee = teeimsic.toCSR.pendings(params.intFilesNum-1,1) //bit(params.intFilesNum-1:1)
    notice_pending   := Mux(cmode, s_orpend_ree.orR, s_orpend_tee.orR)
    teeimsic.fromCSR := fromCSR
    teeimsic.fromCSR.addr.valid := cmode &amp; fromCSR.addr.valid // cmode=1,controls tee csr access to interrupt file indirectly
    teeimsic.fromCSR.wdata.valid := cmode &amp; fromCSR.wdata.valid
    teeimsic.fromCSR.claims(0)   := false.B // machine interrupts are inactive for tee imsic.
    for (i &lt;- 1 until params.privNum) {
      teeimsic.fromCSR.claims(i) := cmode &amp; fromCSR.claims(i)
    }

    imsic.fromCSR.addr.valid := (cmode === false.B) &amp; fromCSR.addr.valid // cmode=1,controls tee csr access to interrupt file indirectly
    imsic.fromCSR.wdata.valid := (cmode === false.B) &amp; fromCSR.wdata.valid
    imsic.fromCSR.claims(0)   := fromCSR.claims(0) // machine interrupts are inactive for tee imsic.
    for (i &lt;- 1 until params.privNum) {
      imsic.fromCSR.claims(i) := (cmode === false.B) &amp; fromCSR.claims(i)
    }
  }
}

//generate TLIMSIC top module:including TLRegIMSIC_WRAP and IMSIC_WRAP
class TLIMSIC(
    params:    IMSICParams,
    beatBytes: Int = 4
//  asyncQueueParams: AsyncQueueParams
)(implicit p: Parameters) extends LazyModule with HasIMSICParameters {
  val axireg      = LazyModule(new TLRegIMSIC_WRAP(IMSICParams(HasTEEIMSIC = GHasTEEIMSIC), beatBytes))
  lazy val module = new Imp

  class Imp extends LazyModuleImp(this) {
    val toCSR         = IO(Output(new IMSICToCSRBundle(params)))
    val fromCSR       = IO(Input(new CSRToIMSICBundle(params)))
    private val imsic = Module(new IMSIC_WRAP(IMSICParams(HasTEEIMSIC = GHasTEEIMSIC), beatBytes))
    toCSR := imsic.toCSR
    imsic.fromCSR := fromCSR
    axireg.module.msiio &lt;&gt; imsic.msiio // msi_req/msi_ack interconnect
    // define additional ports for cvm extention
    val io_sec = if (GHasTEEIMSIC) Some(IO(new ForCVMBundle()))
    else None // include cmode input port,and o_notice_pending output port.
    /* code on when imsic has two clock domains.*/
    // --- define soc_clock for imsic bus logic ***//
    val soc_clock = IO(Input(Clock()))
    val soc_reset = IO(Input(Reset()))
    axireg.module.clock := soc_clock
    axireg.module.reset := soc_reset
    imsic.clock         := clock
    imsic.reset         := reset
    axireg.module.msiio &lt;&gt; imsic.msiio // msi_req/msi_ack interconnect
    // code will be compiled only when io_sec is not None.
    io_sec.foreach(iosec =&gt; imsic.sec.foreach(imsicsec =&gt; imsicsec &lt;&gt; iosec))
    // code will be compiled only when tee_axireg is not None.
    axireg.module.teemsiio.foreach(tee_msi_trans =&gt; imsic.teemsiio.foreach(teemsiio =&gt; tee_msi_trans &lt;&gt; teemsiio))
  }
}

class AXI4IMSIC(
    params:    IMSICParams,
    beatBytes: Int = 4
)(implicit p: Parameters) extends LazyModule with HasIMSICParameters {
  val axireg      = LazyModule(new AXIRegIMSIC_WRAP(IMSICParams(HasTEEIMSIC = GHasTEEIMSIC), beatBytes))
  lazy val module = new Imp
  class Imp extends LazyModuleImp(this) {
    val toCSR         = IO(Output(new IMSICToCSRBundle(params)))
    val fromCSR       = IO(Input(new CSRToIMSICBundle(params)))
    private val imsic = Module(new IMSIC_WRAP(IMSICParams(HasTEEIMSIC = GHasTEEIMSIC), beatBytes))
    toCSR := imsic.toCSR
    imsic.fromCSR := fromCSR
    axireg.module.msiio &lt;&gt; imsic.msiio // msi_req/msi_ack interconnect
    // define additional ports for cvm extention
    val io_sec = if (GHasTEEIMSIC) Some(IO(new ForCVMBundle()))
    else None // include cmode input port,and o_notice_pending output port.
    /* code on when imsic has two clock domains.*/
    // --- define soc_clock for imsic bus logic ***//
    val soc_clock = IO(Input(Clock()))
    val soc_reset = IO(Input(Reset()))
    axireg.module.clock := soc_clock
    axireg.module.reset := soc_reset
    imsic.clock         := clock
    imsic.reset         := reset
    // code will be compiled only when io_sec is not None.
    io_sec.foreach(iosec =&gt; imsic.sec.foreach(imsicsec =&gt; imsicsec &lt;&gt; iosec))
    // code will be compiled only when tee_axireg is not None.
    axireg.module.teemsiio.foreach(tee_msi_trans =&gt; imsic.teemsiio.foreach(teemsiio =&gt; tee_msi_trans &lt;&gt; teemsiio))
  }
}


// code below is for SEC IMSIC spec
//generate TLRegIMSIC_WRAP for IMSIC, when HasCVMExtention is supported, IMSIC is instantiated by two times,else only one
class TLRegIMSIC_WRAP(
    params:    IMSICParams,
    beatBytes: Int = 4
)(implicit p: Parameters) extends LazyModule {
  val axireg = LazyModule(new TLRegIMSIC(params, beatBytes)(Parameters.empty))
  val tee_axireg =
    if (params.HasTEEIMSIC) Some(LazyModule(new TLRegIMSIC(params, beatBytes)(Parameters.empty))) else None
  lazy val module = new TLRegIMSICImp(this)

  class TLRegIMSICImp(outer: LazyModule) extends LazyModuleImp(outer) {
    val msiio = IO(Flipped(new MSITransBundle(params)))
    msiio &lt;&gt; axireg.module.msiio
    val teemsiio = if (params.HasTEEIMSIC) Some(IO(Flipped(new MSITransBundle(params))))
      else None // backpressure signal for axi4bus, from imsic working on cpu clock

    // code below will be compiled only when teeio is not none.
    teemsiio.foreach(teemsiio =&gt; tee_axireg.foreach(tee_axireg =&gt; teemsiio &lt;&gt; tee_axireg.module.msiio))
  }
}

//generate AXIRegIMSIC_WRAP for IMSIC, when HasCVMExtention is supported, IMSIC is instantiated by two times,else only one
class AXIRegIMSIC_WRAP(
    params:    IMSICParams,
    beatBytes: Int = 4
)(implicit p: Parameters) extends LazyModule {
  val axireg = LazyModule(new AXIRegIMSIC(params, beatBytes)(Parameters.empty))
  //  val tee_axireg = if (params.HasTEEIMSIC) Some(LazyModule(new AXIRegIMSIC(IMSICParams(teemode = true), beatBytes)(Parameters.empty))) else None
  val tee_axireg =
    if (params.HasTEEIMSIC) Some(LazyModule(new AXIRegIMSIC(params, beatBytes)(Parameters.empty))) else None
  lazy val module = new AXIRegIMSICImp(this)

  class AXIRegIMSICImp(outer: LazyModule) extends LazyModuleImp(outer) {
    val msiio = IO(Flipped(new MSITransBundle(params))) // backpressure signal for axi4bus, from imsic working on cpu clock
    msiio &lt;&gt; axireg.module.msiio
    val teemsiio = if (params.HasTEEIMSIC) Some(IO(Flipped(new MSITransBundle(params))))
    else None // backpressure signal for axi4bus, from imsic working on cpu clock
    // code below will be compiled only when teeio is not none.
    teemsiio.foreach(teemsiio =&gt; tee_axireg.foreach(tee_axireg =&gt; teemsiio &lt;&gt; tee_axireg.module.msiio))
  }
}

class TLRegIMSIC(
    params:      IMSICParams,
    beatBytes:   Int = 4,
    seperateBus: Boolean = false
)(implicit p: Parameters) extends LazyModule {
  val fromMem = Seq.fill(if (seperateBus) 2 else 1)(TLXbar())
  // val fromMem = LazyModule(new TLXbar).node
  private val intfileFromMems = Seq(
    AddressSet(params.mAddr, pow2(params.intFileMemWidth) - 1),
    AddressSet(params.sgAddr, pow2(params.intFileMemWidth) * pow2(log2Ceil(1 + params.geilen)) - 1)
  ).zipWithIndex.map { case (addrset, i) =&gt;
    val intfileFromMem = TLRegMapperNode(
      address = Seq(addrset),
      beatBytes = beatBytes
    )
    intfileFromMem := (if (seperateBus) fromMem(i) else fromMem.head)
    intfileFromMem
  }

  lazy val module = new TLRegIMSICImp(this)
  class TLRegIMSICImp(outer: LazyModule) extends LazyModuleImp(outer) {
    val msiio = IO(Flipped(new MSITransBundle(params)))  // backpressure signal for axi4bus, from imsic working on cpu clock
    private val reggen = Module(new RegGen(params, beatBytes))
    // ---- instance sync fifo ----//
    // --- fifo wdata: {vector_valid,setipnum}, fifo wren: |vector_valid---//
    val FifoDataWidth = params.MSI_INFO_WIDTH
    val fifo_wdata    = Wire(Valid(UInt(FifoDataWidth.W)))

    // depth:8, data width: FifoDataWidth
    private val fifo_sync = Module(new Queue(UInt(FifoDataWidth.W), 8))
    // define about fifo write
    fifo_wdata.bits        := reggen.io.seteipnum
    fifo_wdata.valid       := reggen.io.valid
    fifo_sync.io.enq.valid := fifo_wdata.valid
    fifo_sync.io.enq.bits  := fifo_wdata.bits
    // fifo rd,controlled by msi_vld_ack from imsic working on csr clock.
    // msi_vld_ack_soc: sync result with soc clock
    val msi_vld_ack_soc = WireInit(false.B)
    val msi_vld_ack_cpu = msiio.vld_ack
    val msi_vld_req     = RegInit(false.B)
    when(params.EnableImsicAsyncBridge.B) {
      msi_vld_ack_soc := AsyncResetSynchronizerShiftReg(msi_vld_ack_cpu, 3, 0)
    }.otherwise {
      msi_vld_ack_soc := msi_vld_ack_cpu
    }
    fifo_sync.io.deq.ready := ~msi_vld_req
    // generate the msi_vld_req: high if ~empty,low when msi_vld_ack_soc
    msiio.vld_req := msi_vld_req
    val msi_vld_ack_soc_1f  = RegNext(msi_vld_ack_soc)
    val msi_vld_ack_soc_ris = msi_vld_ack_soc &amp; (~msi_vld_ack_soc_1f)
    //    val fifo_empty = ~fifo_sync.io.deq.valid
    // msi_vld_req : high when fifo empty is false, low when ack is high. and io.deq.valid := ~empty
    when(msi_vld_ack_soc_ris) {
      msi_vld_req := false.B
    }.elsewhen(fifo_sync.io.deq.valid === true.B) {
      msi_vld_req := true.B
    }.otherwise {
      msi_vld_req := msi_vld_req
    }

    // get the msi interrupt ID info
    val msi_id_data = RegInit(0.U(params.MSI_INFO_WIDTH.W))
    val rdata_vld   = fifo_sync.io.deq.fire // assign to fifo rdata
    when(rdata_vld) { // fire: io.deq.valid &amp; io.deq.ready
      msi_id_data := fifo_sync.io.deq.bits(params.MSI_INFO_WIDTH - 1, 0)
    }.otherwise {
      msi_id_data := msi_id_data
    }
    // port connect: io.valid is interrupt file index info.
    msiio.data := msi_id_data
    val backpress = fifo_sync.io.enq.ready
    (intfileFromMems zip reggen.regmapIOs).map {
      case (intfileFromMem, regmapIO) =&gt; intfileFromMem.regmap(regmapIO._1, regmapIO._2, backpress)
    }
  }
}


//generate axi42reg for IMSIC
class AXIRegIMSIC(
    params:      IMSICParams,
    beatBytes:   Int = 4,
    seperateBus: Boolean = false
)(implicit p: Parameters) extends LazyModule {
  val fromMem = Seq.fill(if (seperateBus) 2 else 1)(AXI4Xbar())
  val axi4tolite = Seq.fill(if (seperateBus) 2 else 1)(LazyModule(new AXI4ToLite()(Parameters.empty)))
  fromMem zip axi4tolite.map(_.node) foreach (x =&gt; x._1 := x._2)
  private val intfileFromMems = Seq(
    AddressSet(params.mAddr, pow2(params.intFileMemWidth) - 1),
    AddressSet(params.sgAddr, pow2(params.intFileMemWidth) * pow2(log2Ceil(1 + params.geilen)) - 1)
  ).zipWithIndex.map { case (addrset, i) =&gt;
    val intfileFromMem = AXI4RegMapperNode(
      address = addrset,
      beatBytes = beatBytes
    )
    intfileFromMem := (if (seperateBus) fromMem(i) else fromMem.head)
    intfileFromMem
  }
  
  lazy val module = new AXIRegIMSICImp(this)
  class AXIRegIMSICImp(outer: LazyModule) extends LazyModuleImp(outer) {
    val msiio          = IO(Flipped(new MSITransBundle(params))) // backpressure signal for axi4bus, from imsic working on cpu clock
    private val reggen = Module(new RegGen(params, beatBytes))
    // ---- instance sync fifo ----//
    // --- fifo wdata: {vector_valid,setipnum}, fifo wren: |vector_valid---//
    val FifoDataWidth = params.MSI_INFO_WIDTH
    val fifo_wdata    = Wire(Valid(UInt(FifoDataWidth.W)))

    // depth:8, data width: FifoDataWidth
    private val fifo_sync = Module(new Queue(UInt(FifoDataWidth.W), 8))
    // define about fifo write
    fifo_wdata.bits        := reggen.io.seteipnum
    fifo_wdata.valid       := reggen.io.valid
    fifo_sync.io.enq.valid := fifo_wdata.valid
    fifo_sync.io.enq.bits  := fifo_wdata.bits
    // fifo rd,controlled by msi_vld_ack from imsic working on csr clock.
    // msi_vld_ack_soc: sync result with soc clock
    val msi_vld_ack_soc = WireInit(false.B)
    val msi_vld_ack_cpu = msiio.vld_ack
    val msi_vld_req     = RegInit(false.B)
    when(params.EnableImsicAsyncBridge.B) {
      msi_vld_ack_soc := AsyncResetSynchronizerShiftReg(msi_vld_ack_cpu, 3, 0)
    }.otherwise {
      msi_vld_ack_soc := msi_vld_ack_cpu
    }
    fifo_sync.io.deq.ready := ~msi_vld_req
    // generate the msi_vld_req: high if ~empty,low when msi_vld_ack_soc
    msiio.vld_req := msi_vld_req
    val msi_vld_ack_soc_1f  = RegNext(msi_vld_ack_soc)
    val msi_vld_ack_soc_ris = msi_vld_ack_soc &amp; (~msi_vld_ack_soc_1f)
    // val fifo_empty = ~fifo_sync.io.deq.valid
    // msi_vld_req : high when fifo empty is false, low when ack is high. and io.deq.valid := ~empty
    when(msi_vld_ack_soc_ris) {
      msi_vld_req := false.B
    }.elsewhen(fifo_sync.io.deq.valid === true.B) {
      msi_vld_req := true.B
    }.otherwise {
      msi_vld_req := msi_vld_req
    }

    // get the msi interrupt ID info
    val msi_id_data = RegInit(0.U(params.MSI_INFO_WIDTH.W))
    val rdata_vld   = fifo_sync.io.deq.fire // assign to fifo rdata
    when(rdata_vld) { // fire: io.deq.valid &amp; io.deq.ready
      msi_id_data := fifo_sync.io.deq.bits(params.MSI_INFO_WIDTH - 1, 0)
    }.otherwise {
      msi_id_data := msi_id_data
    }
    // port connect: io.valid is interrupt file index info.
    msiio.data := msi_id_data
    val backpress = fifo_sync.io.enq.ready
    (intfileFromMems zip reggen.regmapIOs).map {
      case (intfileFromMem, regmapIO) =&gt; intfileFromMem.regmap(regmapIO._1, regmapIO._2, backpress)
    }
  }
}

//integrated for async clock domain,kmh,zhaohong
class RegGen(
    params:    IMSICParams,
    beatBytes: Int = 4
) extends Module {
  val regmapIOs = Seq(
    params.intFileMemWidth,
    params.intFileMemWidth + log2Ceil(1 + params.geilen)
  ).map { width =&gt;
    val regmapParams = RegMapperParams(width - log2Up(beatBytes), beatBytes)
    (IO(Flipped(Decoupled(new RegMapperInput(regmapParams)))), IO(Decoupled(new RegMapperOutput(regmapParams))))
  }
  // define the output reg: seteipnum is the MSI id,vld[],valid flag for interrupt file domains: m,s,vs1~vsgeilen
  val io = IO(Output(new Bundle {
    val seteipnum = UInt(params.MSI_INFO_WIDTH.W)
    val valid     = Bool()
  }))
  val valids       = WireInit(VecInit(Seq.fill(params.intFilesNum)(false.B)))
  val seteipnums   = WireInit(VecInit(Seq.fill(params.intFilesNum)(0.U(params.imsicIntSrcWidth.W))))
  val outseteipnum = RegInit(0.U(params.MSI_INFO_WIDTH.W))
  val outvalids    = RegInit(VecInit(Seq.fill(params.intFilesNum)(false.B)))

  (regmapIOs zip Seq(1, 1 + params.geilen)).zipWithIndex.map { // seq[0]: m interrupt file, seq[1]: s&amp;vs interrupt file
    case ((regmapIO: (DecoupledIO[RegMapperInput], DecoupledIO[RegMapperOutput]), intFilesNum: Int), i: Int) =&gt;
      {
        // j: index is 0 for m file for seq[0],index is 0~params.geilen for S intFile for seq[1]: S, G1, G2, ...
        val maps = (0 until intFilesNum).map { j =&gt;
          val flati = i + j // seq[0]:0+0=0;seq[1]:(0~geilen)+1
          val seteipnum = WireInit(0.U.asTypeOf(Valid(UInt(params.imsicIntSrcWidth.W)))); /*for debug*/
          dontTouch(seteipnum)
          valids(flati)     := seteipnum.valid
          seteipnums(flati) := seteipnum.bits
          j * pow2(params.intFileMemWidth).toInt -&gt; Seq(RegField(
            32,
            0.U,
            RegWriteFn { (valid, data) =&gt;
              when(valid) { seteipnum.bits := data(params.imsicIntSrcWidth - 1, 0); seteipnum.valid := true.B }; true.B
            }
          ))
        }
        regmapIO._2 &lt;&gt; RegMapper(beatBytes, 1, true, regmapIO._1, maps: _*)
      }
      for (i &lt;- 0 until params.intFilesNum) {
        when(valids(i)) {
          outseteipnum := Cat(i.U, seteipnums(i))
        }
      }
      outvalids    := valids
      io.seteipnum := outseteipnum
      io.valid     := outvalids.reduce(_ | _)
  }
}```

### `APLICParams`

APLICÊé•Êî∂ÁöÑ‰∏≠Êñ≠Ê∫êÊï∞ÈáèÁöÑÂØπÊï∞„ÄÇ
ÈªòËÆ§ÂÄº7Ë°®Á§∫APLICÊîØÊåÅÊúÄÂ§ö128Ôºà2^7Ôºâ‰∏™‰∏≠Êñ≠Ê∫ê„ÄÇ
**Ê≥®ÊÑè**Ôºö`aplicIntSrcWidth`ÂøÖÈ°ªÂ∞è‰∫é`imsicIntSrcWidth`Ôºå
Âõ†‰∏∫APLICÁöÑ‰∏≠Êñ≠Ê∫êÂ∞ÜË¢´ËΩ¨Êç¢‰∏∫MSIÔºå
ËÄåAPLICËΩ¨Êç¢ÊàêÁöÑMSIÊòØIMSIC‰∏≠Êñ≠Ê∫êÁöÑÂ≠êÈõÜ„ÄÇ
ÔºàLogarithm of number of interrupt sources to APLIC:
The default 7 means APLIC support at most 128 (2^7) interrupt sources.
**Note**: `aplicIntSrcWidth` must be **less than** `imsicIntSrcWidth`,
as APLIC interrupt sources are converted to MSIs,
which are a subset of IMSIC's interrupt sourcesÔºâÔºö

```scala
  aplicIntSrcWidth: Int = 7,
  imsicIntSrcWidth: Int = 9,
</code></pre>
<p>üëâ APLICÂüüÁöÑÂü∫Âú∞ÂùÄÔºàBase address of APLIC domainsÔºâ:</p>
<pre><code class="language-scala">  baseAddr: Long = 0x19960000L,
</code></pre>
<p><strong>Ê≥®ÊÑè</strong>Ôºö‰∏ãËø∞‰∏≠Êã¨Âè∑ÂÜÖÁöÑÂèòÈáè‰∏éAIAËßÑËåÉ‰∏≠ÁöÑ‰∏ÄËá¥ÔºàÁ¨¨3.6ËäÇÔºöÁî®‰∫éÂ§ö‰∏™‰∏≠Êñ≠Êñá‰ª∂ÁöÑÂÜÖÂ≠òÂå∫ÂüüÊéíÂàóÔºâ„ÄÇ</p>
<p><strong>Note</strong>: The following variables in bracket align with the AIA specification (Section 3.6: Memory Region Arrangement for Multiple Interrupt Files).</p>
<p>üëâ ÊØè‰∏™ÁªÑÁöÑÊàêÂëòÊï∞ÈáèÔºàNumber of members per groupÔºâ[\(h_{max}\)]Ôºö</p>
<pre><code class="language-scala">  membersNum      : Int  = 2           ,
</code></pre>
<p>üëâ ÊâÄÊúâIMSICÁöÑÊú∫Âô®ÊÄÅ‰∏≠Êñ≠Êñá‰ª∂ÁöÑÂü∫Âú∞ÂùÄÔºàBase address of machine-level interrupt files for all IMSICsÔºâ[\(A\)]Ôºö</p>
<pre><code class="language-scala">  mBaseAddr       : Long = 0x61000000L ,
</code></pre>
<p>üëâ ÊâÄÊúâIMSICÁöÑÁõëÁÆ°ÊÄÅÂíåÂÆ¢Êà∑ÊÄÅ‰∏≠Êñ≠Êñá‰ª∂ÁöÑÂü∫Âú∞ÂùÄÔºàBase addr for supervisor-level and guest-level interrupt files for all IMSICsÔºâ[\(B\)]:</p>
<pre><code class="language-scala">  sgBaseAddr      : Long = 0x82900000L ,
</code></pre>
<p>üëâ ÁªÑÁöÑÊï∞ÈáèÔºàNumber of groups Ôºâ[\(g_{max}\)]:</p>
<pre><code class="language-scala">  groupsNum       : Int  = 1           ,
</code></pre>
<p>üëâ ÂÆ¢Êà∑‰∏≠Êñ≠Êñá‰ª∂ÁöÑÊï∞ÈáèÔºàNumber of guest interrupt filesÔºâ:</p>
<pre><code class="language-scala">  geilen          : Int  = 7           ,
</code></pre>
<h2 id="ÂÆû‰æãÂåñinstantiation"><a class="header" href="#ÂÆû‰æãÂåñinstantiation">ÂÆû‰æãÂåñÔºàInstantiationÔºâ</a></h2>
<ul>
<li>
<p><code>APLICParams</code>Âíå<code>IMSICParams</code>Ôºö</p>
<ul>
<li>ÊØè‰∏™Á±ª‰∏Ä‰∏™ÂÆû‰æãÔºå</li>
<li>Ê†πÊçÆ<a href="integration.html#%E5%8F%82%E6%95%B0parameters">ÂèÇÊï∞</a>ÈÉ®ÂàÜÁöÑËØ¥ÊòéÔºåÂÆû‰æãÂåñÂèÇÊï∞„ÄÇ</li>
</ul>
</li>
<li>
<p><code>TLAPLIC</code>/<code>AXI4APLIC</code>Ôºö</p>
<ul>
<li>Âçï‰∏™ÂÆû‰æãÔºå</li>
<li>ÂèÇÊï∞<code>params</code>ÔºöÊé•Êî∂<code>APLICParams</code>ÁöÑÂÆû‰æãÔºå</li>
</ul>
</li>
<li>
<p><code>TLIMSIC</code>/<code>AXI4IMSIC</code>Ôºö</p>
<ul>
<li>ÊØè‰∏™Ê†∏ÂøÉ‰∏Ä‰∏™ÂÆû‰æãÔºå</li>
<li>ÂèÇÊï∞<code>params</code>ÔºöÊé•Êî∂<code>IMSICParams</code>ÁöÑÂÆû‰æãÔºå</li>
</ul>
</li>
<li>
<p><code>APLICParams</code> and <code>IMSICParams</code>:</p>
<ul>
<li>Single instance each,</li>
<li>Instantiation parameters according to <a href="integration.html#%E5%8F%82%E6%95%B0parameters">Parameters</a> section.</li>
</ul>
</li>
<li>
<p><code>TLAPLIC</code>/<code>AXI4APLIC</code>:</p>
<ul>
<li>Single instance,</li>
<li>Parameter <code>params</code>: receiving the <code>APLICParams</code>'s instance,</li>
</ul>
</li>
<li>
<p><code>TLIMSIC</code>/<code>AXI4IMSIC</code>:</p>
<ul>
<li>One instance per hart,</li>
<li>Parameter <code>params</code>: receiving the <code>IMSICParams</code>'s instance,</li>
</ul>
</li>
</ul>
<!-- TODO: find a right place for hartIndex -->
<h3 id="ÂÖ≥‰∫éhartindexabout-hartindex"><a class="header" href="#ÂÖ≥‰∫éhartindexabout-hartindex"><span style="color:red;">ÂÖ≥‰∫éhartIndexÔºàAbout hartIndexÔºâ</span></a></h3>
<p>Ê†πÊçÆAIAËßÑËåÉÔºö
<span style="color:red;">AIAÁöÑhartÁºñÂè∑</span>
ÂèØËÉΩ‰∏éRISC-VÁâπÊùÉÊû∂ÊûÑÂàÜÈÖçÁªôhartÁöÑÂîØ‰∏Ä
<span style="color:red;">hartÊ†áËØÜÁ¨¶Ôºà‚Äúhart ID‚ÄùÔºâÊó†ÂÖ≥</span>„ÄÇ
Âú®ChiselAIA‰∏≠ÔºåhartIndexÁºñÁ†Å‰∏∫groupIDÊãºÊé•‰∏ämemberID„ÄÇ</p>
<p>According to the AIA specification:
The <span style="color:red;">AIA's hart index</span> may or
<span style="color:red;">may not have any relationship to</span> the unique
<span style="color:red;">hart identifier ("hart ID")</span>
that the RISC-V Privileged Architecture assigns to the hart.
In ChiselAIA, the hartIndex is encoded as a concatenation of <code>groupID</code> and <code>memberID</code>:</p>
<p><img src="./images/hart_index.svg" alt="" /></p>
<h2 id="Á§∫‰æãexamples"><a class="header" href="#Á§∫‰æãexamples">Á§∫‰æãÔºàExamplesÔºâ</a></h2>
<!-- TODO: markcode A Grouped 4-Hart System -->
<h3 id="ÁÆÄÂçïÁöÑ4Ê†∏Á≥ªÁªüa-simple-4-hart-system"><a class="header" href="#ÁÆÄÂçïÁöÑ4Ê†∏Á≥ªÁªüa-simple-4-hart-system">ÁÆÄÂçïÁöÑ4Ê†∏Á≥ªÁªüÔºàA Simple 4-Hart SystemÔºâ</a></h3>
<p>ÂØπ‰∫é‰∏Ä‰∏™ÁÆÄÂçïÁöÑÊú™ÂàÜÁªÑÁ≥ªÁªüÔºåËÆæÁΩÆgroupsNum=1ÔºåÂàôÂèØ‰ª•Â∞Ühart IDÂ§çÁî®‰Ωú‰∏∫AIAÁöÑ`hartIndexÔºö</p>
<p>For a simple ungrouped system, set groupsNum=1 to allow reuse of hart ID as AIA's <code>hartIndex</code>:</p>
<pre><code class="language-scala">val imsic_params = IMSICParams()
val aplic_params = APLICParams(groupsNum=1, membersNum=4)
val imsics = (0 until 4).map( i =&gt; {
  val imsic = LazyModule(new TLIMSIC(imsic_params)(Parameters.empty))
val aplic = LazyModule(new TLAPLIC(aplic_params)(Parameters.empty))
</code></pre>
<h3 id="ÂàÜÁªÑÁöÑ4Ê†∏Á≥ªÁªüa-grouped-4-hart-system"><a class="header" href="#ÂàÜÁªÑÁöÑ4Ê†∏Á≥ªÁªüa-grouped-4-hart-system">ÂàÜÁªÑÁöÑ4Ê†∏Á≥ªÁªüÔºàA Grouped 4-Hart SystemÔºâ</a></h3>
<p>Âú®<code>src/main/scala/Example.AIA</code>Âíå<code>src/main/scala/Example-axi.scala</code>‰∏≠ÔºåÊàë‰ª¨Êèê‰æõ‰∫Ü‰∏Ä‰∏™Â¶Ç‰ΩïÂÆû‰æãÂåñAPLICÊ†∏IMSICÁöÑÁ§∫‰æã
ÔºàÊàë‰ª¨ÁöÑÂçïÂÖÉÊµãËØï‰πüÊòØÂü∫‰∫éËØ•Á§∫‰æãÔºâ„ÄÇ
‰ª•Tilelink‰∏∫‰æãÔºåÊàë‰ª¨Êé•‰∏ãÊù•Â±ïÁ§∫‰∏Ä‰∫õÂÖ≥ÈîÆÁöÑ‰ª£Á†ÅÔºö</p>
<p>We provide an example of instantiating the APLIC and IMSIC, in <code>src/main/scala/Example.AIA</code> and <code>src/main/scala/Example-axi.scala</code>
(Furthermore, we will use this example to conduct unit tests.).
Take Tilelink as an example, we provide key lines of code below:</p>
<pre><code class="language-scala">val imsic_params = IMSICParams()
val aplic_params = APLICParams(groupsNum=2, membersNum=2)
val imsics = (0 until 4).map( i =&gt; {
  val imsic = LazyModule(new TLIMSIC(imsic_params)(Parameters.empty))
val aplic = LazyModule(new TLAPLIC(aplic_params)(Parameters.empty))
</code></pre>
<p>Ê≠§ÈÖçÁΩÆÂàõÂª∫‰∫Ü‰∏Ä‰∏™2‰ΩçÁöÑ<code>hartIndex</code>ÔºåÈ´ò‰ΩçË°®Á§∫ groupIDÔºå‰Ωé‰ΩçË°®Á§∫ memberID„ÄÇ
ÊúâÂÖ≥ËØ¶ÁªÜÁöÑIOËøûÊé•ÔºåËØ∑ÂèÇËÄÉ‰∏ãÂõæÂíå<code>src/main/scala/Example.AIA</code>„ÄÇ</p>
<p>This configuration creates a 2-bit <code>hartIndex</code> where the higher bit represents <code>groupID</code> and the lower bit represents <code>memberID</code>.
For detailed IO connections, refer to the following figure and <code>src/main/scala/Example.AIA</code>.</p>
<p><img src="./images/example_py.svg" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
